<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="1.Linux命令（文件管理）, yoyo，LHL001">
    <meta name="description" content="1.文件管理1.catcat 命令用于连接文件并打印到标准输出设备上。
使用权限所有使用者
语法格式cat [-AbeEnstTuv] [--help] [--version] fileName参数说明：-n 或 –number：由 1 开">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>1.Linux命令（文件管理） | yoyo</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">yoyo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">yoyo</div>
        <div class="logo-desc">
            
            当时间的主人，命运的主宰，灵魂的舵手。   ——罗斯福
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        1.Linux命令（文件管理）
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Linux命令/" target="_blank">
                                <span class="chip bg-color">Linux命令</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Linux笔记/" class="post-category" target="_blank">
                                Linux笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-08-18
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        24.8k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        99 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1.文件管理"></a>1.文件管理</h1><h2 id="1-cat"><a href="#1-cat" class="headerlink" title="1.cat"></a>1.cat</h2><p>cat 命令用于连接文件并打印到标准输出设备上。</p>
<h3 id="使用权限"><a href="#使用权限" class="headerlink" title="使用权限"></a>使用权限</h3><p>所有使用者</p>
<h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><pre><code>cat [-AbeEnstTuv] [--help] [--version] fileName</code></pre><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><p><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。</p>
<p><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。</p>
<p><strong>-s 或 –squeeze-blank</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行。</p>
<p><strong>-v 或 –show-nonprinting</strong>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。</p>
<p><strong>-E 或 –show-ends</strong> : 在每行结束处显示 $。</p>
<p><strong>-T 或 –show-tabs</strong>: 将 TAB 字符显示为 ^I。</p>
<p><strong>-A, –show-all</strong>：等价于 -vET。</p>
<p><strong>-e：</strong>等价于”-vE”选项；</p>
<p><strong>-t：</strong>等价于”-vT”选项；</p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</p>
<pre><code>cat -n textfile1 &gt; textfile2</code></pre><p>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</p>
<pre><code>cat -b textfile1 textfile2 &gt;&gt; textfile3</code></pre><p>清空 /etc/test.txt 文档内容：</p>
<pre><code>cat /dev/null &gt; /etc/test.txt</code></pre><p>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：</p>
<pre><code>cat /dev/fd0 &gt; OUTFILE</code></pre><p>相反的，如果想把 image file 写到软盘，输入：</p>
<pre><code>cat IMG_FILE &gt; /dev/fd0</code></pre><p><strong>注</strong>：</p>
<ul>
<li>\1. OUTFILE 指输出的镜像文件名。</li>
<li>\2. IMG_FILE 指镜像文件。</li>
<li>\3. 若从镜像文件写回 device 时，device 容量需与相当。</li>
<li>\4. 通常用制作开机磁片。</li>
</ul>
<h2 id="2-chattr"><a href="#2-chattr" class="headerlink" title="2.chattr"></a>2.chattr</h2><p> chattr 命令用于改变文件属性。</p>
<p>这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：</p>
<ol>
<li>a：让文件或目录仅供附加用途。</li>
<li>b：不更新文件或目录的最后存取时间。</li>
<li>c：将文件或目录压缩后存放。</li>
<li>d：将文件或目录排除在倾倒操作之外。</li>
<li>i：不得任意更动文件或目录。</li>
<li>s：保密性删除文件或目录。</li>
<li>S：即时更新文件或目录。</li>
<li>u：预防意外删除。</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...]</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。</p>
<p>　　-v&lt;版本编号&gt; 设置文件或目录版本。</p>
<p>　　-V 显示指令执行过程。</p>
<p>　　+&lt;属性&gt; 开启文件或目录的该项属性。</p>
<p>　　-&lt;属性&gt; 关闭文件或目录的该项属性。</p>
<p>　　=&lt;属性&gt; 指定文件或目录的该项属性。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>用chattr命令防止系统中某个关键文件被修改：</p>
<pre><code>chattr +i /etc/resolv.conf
lsattr /etc/resolv.conf</code></pre><p>会显示如下属性</p>
<pre><code>----i-------- /etc/resolv.conf</code></pre><p>让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：</p>
<pre><code>chattr +a /var/log/messages</code></pre><h2 id="3-chgrp"><a href="#3-chgrp" class="headerlink" title="3. chgrp"></a>3. chgrp</h2><p>chgrp 命令 用于变更文件或目录的所属群组。</p>
<p>在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</code></pre><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>　　-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</p>
<p>　　-f或–quiet或–silent 　不显示错误信息。</p>
<p>　　-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</p>
<p>　　-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p>
<p>　　-v或–verbose 　显示指令执行过程。</p>
<p>　　–help 　在线帮助。</p>
<p>　　–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</p>
<p>　　–version 　显示版本信息。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>实例1：改变文件的群组属性：</p>
<pre><code>chgrp -v bin log2012.log</code></pre><p>输出：</p>
<pre><code>[root@localhost test]# ll
---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log
[root@localhost test]# chgrp -v bin log2012.log</code></pre><p>“log2012.log” 的所属组已更改为 bin</p>
<pre><code>[root@localhost test]# ll
---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log</code></pre><p>说明： 将log2012.log文件由root群组改为bin群组</p>
<p>实例2：根据指定文件改变文件的群组属性</p>
<pre><code>chgrp --reference=log2012.log log2013.log</code></pre><p>输出：</p>
<pre><code>[root@localhost test]# ll
---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log
-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log
[root@localhost test]#  chgrp --reference=log2012.log log2013.log 
[root@localhost test]# ll
---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log
-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</code></pre><p>说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同</p>
<h2 id="4-chmod"><a href="#4-chmod" class="headerlink" title="4.chmod"></a>4.chmod</h2><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
<p><strong>使用权限</strong> : 所有使用者</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre><code>chmod [-cfvR] [--help] [--version] mode file...</code></pre><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><p>mode : 权限设定字串，格式如下 :</p>
<pre><code>[ugoa...][[+-=][rwxX]...][,...]</code></pre><p>其中：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<pre><code>chmod ugo+r file1.txt</code></pre><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<pre><code>chmod a+r file1.txt</code></pre><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<pre><code>chmod ug+w,o-w file1.txt file2.txt</code></pre><p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p>
<pre><code>chmod u+x ex1.py</code></pre><p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<pre><code>chmod -R a+r *</code></pre><p>此外chmod也可以用数字来表示权限如 :</p>
<pre><code>chmod 777 file</code></pre><p>语法为：</p>
<pre><code>chmod abc file</code></pre><p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<h4 id="r-4，w-2，x-1"><a href="#r-4，w-2，x-1" class="headerlink" title="r=4，w=2，x=1"></a>r=4，w=2，x=1</h4><ul>
<li>若要rwx属性则4+2+1=7；</li>
<li>若要rw-属性则4+2=6；</li>
<li>若要r-x属性则4+1=5。</li>
</ul>
<pre><code>chmod a=rwx file</code></pre><p>和</p>
<pre><code>chmod 777 file</code></pre><p>效果相同</p>
<pre><code>chmod ug=rwx,o=x file</code></pre><p>和</p>
<pre><code>chmod 771 file</code></pre><p>效果相同</p>
<p>若用chmod 4755 filename可使此程序具有root的权限</p>
<h2 id="5-chown"><a href="#5-chown" class="headerlink" title="5.chown"></a>5.chown</h2><p>​        Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。</p>
<p>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</p>
<p><strong>使用权限</strong> : root</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre><code>chown [-cfhvR] [--help] [--version] user[:group] file...</code></pre><p><strong>参数</strong> :</p>
<ul>
<li>user : 新的文件拥有者的使用者 ID</li>
<li>group : 新的文件拥有者的使用者组(group)</li>
<li>-c : 显示更改的部分的信息</li>
<li>-f : 忽略错误信息</li>
<li>-h :修复符号链接</li>
<li>-v : 显示详细的处理信息</li>
<li>-R : 处理指定目录以及其子目录下的所有文件</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p>
<pre><code>chown runoob:runoobgroup file1.txt</code></pre><p>将目前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p>
<pre><code>chown -R runoob:runoobgroup *</code></pre><h2 id="6-cksum"><a href="#6-cksum" class="headerlink" title="6.cksum"></a>6.cksum</h2><p>​         cksum命令用于检查文件的CRC是否正确。确保文件从一个系统传输到另一个系统的过程中不被损坏。</p>
<p>CRC是一种排错检查方式，该校验法的标准由CCITT所指定，至少可检测到99.998%的已知错误。</p>
<p>指定文件交由指令”cksum”进行校验后，该指令会返回校验结果供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为”-“，则指令”cksum”会从标准输入设备中读取数据。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><pre><code>cksum [--help][--version][文件...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>–help：在线帮助。</li>
<li>–version：显示版本信息。</li>
<li>文件…:需要进行检查的文件路径</li>
</ul>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>使用指令”cksum”计算文件”testfile1”的完整性，输入如下命令：</p>
<pre><code>$ cksum testfile1       </code></pre><p>以上命令执行后，将输出校验码等相关的信息，具体输出信息如下所示：</p>
<pre><code>1263453430 78 testfile1         //输出信息 </code></pre><p>上面的输出信息中，”1263453430”表示校验码，”78”表示字节数。</p>
<p><strong>注意：</strong>如果文件中有任何字符被修改，都将改变计算后CRC校验码的值。</p>
<h2 id="7-cmp"><a href="#7-cmp" class="headerlink" title="7. cmp"></a>7. cmp</h2><p>​        cmp命令用于比较两个文件是否有差异。</p>
<p>当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为”-“，则cmp指令会从标准输入设备读取数据。</p>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><pre><code>cmp [-clsv][-i &lt;字符数目&gt;][--help][第一个文件][第二个文件]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-c或–print-chars 　除了标明差异处的十进制字码之外，一并显示该字符所对应字符。</li>
<li>-i&lt;字符数目&gt;或–ignore-initial=&lt;字符数目&gt; 　指定一个数目。</li>
<li>-l或–verbose 　标示出所有不一样的地方。</li>
<li>-s或–quiet或–silent 　不显示错误信息。</li>
<li>-v或–version 　显示版本信息。</li>
<li>–help 　在线帮助。</li>
</ul>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>要确定两个文件是否相同，请输入：</p>
<pre><code>cmp prog.o.bak prog.o </code></pre><p>这比较 prog.o.bak 和 prog.o。如果文件相同，则不显示消息。如果文件不同，则显示第一个不同的位置；例如：</p>
<pre><code>prog.o.bak prog.o differ: char 4, line 1 </code></pre><p>如果显示消息 cmp: EOF on prog.o.bak，则 prog.o 的第一部分与 prog.o.bak 相同，但在 prog.o 中还有其他数据。</p>
<h2 id="8-diff"><a href="#8-diff" class="headerlink" title="8.diff"></a>8.diff</h2><p>​        diff命令用于比较文件的差异。</p>
<p>diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><pre><code>diff [-abBcdefHilnNpPqrstTuvwy][-&lt;行数&gt;][-C &lt;行数&gt;][-D &lt;巨集名称&gt;][-I &lt;字符或字符串&gt;][-S &lt;文件&gt;][-W &lt;宽度&gt;][-x &lt;文件或目录&gt;][-X &lt;文件&gt;][--help][--left-column][--suppress-common-line][文件或目录1][文件或目录2]</code></pre><p><strong>参数</strong>：</p>
<p>-&lt;行数&gt; 　指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</p>
<p>-a或–text 　diff预设只会逐行比较文本文件。</p>
<p>-b或–ignore-space-change 　不检查空格字符的不同。</p>
<ul>
<li>-B或–ignore-blank-lines 　不检查空白行。</li>
<li>-c 　显示全部内文，并标出不同之处。</li>
<li>-C&lt;行数&gt;或–context&lt;行数&gt; 　与执行”-c-&lt;行数&gt;”指令相同。</li>
<li>-d或–minimal 　使用不同的演算法，以较小的单位来做比较。</li>
<li>-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt; 　此参数的输出格式可用于前置处理器巨集。</li>
<li>-e或–ed 　此参数的输出格式可用于ed的script文件。</li>
<li>-f或-forward-ed 　输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</li>
<li>-H或–speed-large-files 　比较大文件时，可加快速度。</li>
<li>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 　若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</li>
<li>-i或–ignore-case 　不检查大小写的不同。</li>
<li>-l或–paginate 　将结果交由pr程序来分页。</li>
<li>-n或–rcs 　将比较结果以RCS的格式来显示。</li>
<li>-N或–new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：</li>
<li>Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</li>
<li>-p 　若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</li>
<li>-P或–unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</li>
<li>-q或–brief 　仅显示有无差异，不显示详细的信息。</li>
<li>-r或–recursive 　比较子目录中的文件。</li>
<li>-s或–report-identical-files 　若没有发现任何差异，仍然显示信息。</li>
<li>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 　在比较目录时，从指定的文件开始比较。</li>
<li>-t或–expand-tabs 　在输出时，将tab字符展开。</li>
<li>-T或–initial-tab 　在每行前面加上tab字符以便对齐。</li>
<li>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 　以合并的方式来显示文件内容的不同。</li>
<li>-v或–version 　显示版本信息。</li>
<li>-w或–ignore-all-space 　忽略全部的空格字符。</li>
<li>-W&lt;宽度&gt;或–width&lt;宽度&gt; 　在使用-y参数时，指定栏宽。</li>
<li>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 　不比较选项中所指定的文件或目录。</li>
<li>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 　您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件。</li>
<li>-y或–side-by-side 　以并列的方式显示文件的异同之处。</li>
<li>–help 　显示帮助。</li>
<li>–left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li>
<li>–suppress-common-lines 　在使用-y参数时，仅显示不同之处。</li>
</ul>
<h3 id="实例1：比较两个文件"><a href="#实例1：比较两个文件" class="headerlink" title="实例1：比较两个文件"></a>实例1：比较两个文件</h3><pre><code>[root@localhost test3]# diff log2014.log log2013.log 
3c3
&lt; 2014-03
---
&gt; 2013-03
8c8
&lt; 2013-07
---
&gt; 2013-08
11,12d10
&lt; 2013-11
&lt; 2013-12</code></pre><p>上面的”3c3”和”8c8”表示log2014.log和log20143log文件在3行和第8行内容有所不同；”11,12d10”表示第一个文件比第二个文件多了第11和12行。</p>
<h3 id="实例2：并排格式输出"><a href="#实例2：并排格式输出" class="headerlink" title="实例2：并排格式输出"></a>实例2：并排格式输出</h3><pre><code>[root@localhost test3]# diff log2014.log log2013.log  -y -W 50
2013-01                 2013-01
2013-02                 2013-02
2014-03               | 2013-03
2013-04                 2013-04
2013-05                 2013-05
2013-06                 2013-06
2013-07                 2013-07
2013-07               | 2013-08
2013-09                 2013-09
2013-10                 2013-10
2013-11               &lt;
2013-12               &lt;
[root@localhost test3]# diff log2013.log log2014.log  -y -W 50
2013-01                 2013-01
2013-02                 2013-02
2013-03               | 2014-03
2013-04                 2013-04
2013-05                 2013-05
2013-06                 2013-06
2013-07                 2013-07
2013-08               | 2013-07
2013-09                 2013-09
2013-10                 2013-10
                      &gt; 2013-11
                      &gt; 2013-12</code></pre><p><strong>说明：</strong></p>
<ul>
<li>“|”表示前后2个文件内容有不同</li>
<li>“&lt;”表示后面文件比前面文件少了1行内容</li>
<li>“&gt;”表示后面文件比前面文件多了1行内容</li>
</ul>
<h2 id="9-diffstat"><a href="#9-diffstat" class="headerlink" title="9.diffstat"></a>9.diffstat</h2><p>​         diffstat命令根据diff的比较结果，显示统计数字。</p>
<p>diffstat读取diff的输出结果，然后统计各文件的插入，删除，修改等差异计量。</p>
<h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><pre><code>diff [-wV][-n &lt;文件名长度&gt;][-p &lt;文件名长度&gt;]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</li>
<li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。</li>
<li>-w 　指定输出时栏位的宽度。</li>
<li>-V 　显示版本信息。</li>
</ul>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>用户也可以直接使用”|”将diff指令所输出的结果直接送给diffstat指令进行统计结果的显示。</p>
<p>使用该指令时，若所比较的文件或者子目录不在当前目录下，则应该使用其完整路径。</p>
<p>将目录”test1”和”test2”下的同名文件”testf.txt”使用diff指令进行比较。然后使用diffstat指令对结果进行统计显示，输入如下命令：</p>
<pre><code>$ diff test1 test2 | diffstat   #进行比较结果的统计显示</code></pre><p>注意：使用这条命令可以非常方便地实现统计显示的功能。</p>
<p>对于查看文件中的内容，用户可以通过指令”cat”进行查看即可，具体操作如下：</p>
<pre><code>$ cat test1/testf.txt           #查看test1/testf的内容  
abc  
def  
ghi  
jkl  
mno  
pqr  
stu  
vws  
$ cat test2/testf.txt           #查看test2/testf的内容  
abc  
def  
ghi  
jkl  
mno</code></pre><p>从上面的文件内容显示，可以看到两个文件内容的差别。现在来运行刚才的命令，对文件比较的结果进行统计显示，结果如下：</p>
<h2 id="10-file"><a href="#10-file" class="headerlink" title="10.file"></a>10.file</h2><p>​         file命令用于辨识文件类型。</p>
<p>通过file指令，我们得以辨识该文件的类型。</p>
<h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><pre><code>file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-b 　列出辨识结果时，不显示文件名称。</li>
<li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</li>
<li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</li>
<li>-L 　直接显示符号连接所指向的文件的类别。</li>
<li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</li>
<li>-v 　显示版本信息。</li>
<li>-z 　尝试去解读压缩文件的内容。</li>
<li>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</li>
</ul>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>显示文件类型：</p>
<pre><code>[root@localhost ~]# file install.log
install.log: UTF-8 Unicode text

[root@localhost ~]# file -b install.log      &lt;== 不显示文件名称
UTF-8 Unicode text

[root@localhost ~]# file -i install.log      &lt;== 显示MIME类别。
install.log: text/plain; charset=utf-8

[root@localhost ~]# file -b -i install.log
text/plain; charset=utf-8</code></pre><p>显示符号链接的文件类型</p>
<pre><code>[root@localhost ~]# ls -l /var/mail
lrwxrwxrwx 1 root root 10 08-13 00:11 /var/mail -&gt; spool/mail

[root@localhost ~]# file /var/mail
/var/mail: symbolic link to `spool/mail&#39;

[root@localhost ~]# file -L /var/mail
/var/mail: directory

[root@localhost ~]# file /var/spool/mail
/var/spool/mail: directory

[root@localhost ~]# file -L /var/spool/mail
/var/spool/mail: directory</code></pre><h2 id="11-find"><a href="#11-find" class="headerlink" title="11.find"></a>11.find</h2><p>​        find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><pre><code>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code></pre><p><strong>参数说明</strong> :</p>
<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>
<p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p>
<p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p>
<p>-amin n : 在过去 n 分钟内被读取过</p>
<p>-anewer file : 比文件 file 更晚被读取过的文件</p>
<p>-atime n : 在过去n天内被读取过的文件</p>
<p>-cmin n : 在过去 n 分钟内被修改过</p>
<p>-cnewer file :比文件 file 更新的文件</p>
<p>-ctime n : 在过去n天内被修改过的文件</p>
<p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p>
<p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p>
<p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p>
<p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p>
<p>d: 目录</p>
<p>c: 字型装置文件</p>
<p>b: 区块装置文件</p>
<p>p: 具名贮列</p>
<p>f: 一般文件</p>
<p>l: 符号连结</p>
<p>s: socket</p>
<p>-pid n : process id 是 n 的文件</p>
<p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p>
<p>exp1 -and exp2</p>
<p>! expr</p>
<p>-not expr</p>
<p>exp1 -or exp2</p>
<p>exp1, exp2</p>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</p>
<pre><code># find . -name &quot;*.c&quot;</code></pre><p>将目前目录其其下子目录中所有一般文件列出</p>
<pre><code># find . -type f</code></pre><p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p>
<pre><code># find . -ctime -20</code></pre><p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：</p>
<pre><code># find /var/log -type f -mtime +7 -ok rm {} \;</code></pre><p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：</p>
<pre><code># find . -type f -perm 644 -exec ls -l {} \;</code></pre><p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：</p>
<pre><code># find / -type f -size 0 -exec ls -l {} \;</code></pre><h2 id="12-git"><a href="#12-git" class="headerlink" title="12.git"></a>12.git</h2><p>​        git命令是文字模式下的文件管理员。</p>
<p>git是用来管理文件的程序，它十分类似DOS下的Norton Commander，具有互动式操作界面。它的操作方法和Norton Commander几乎一样。</p>
<h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><pre><code>git</code></pre><p>操作说明：</p>
<ul>
<li>F1 ：执行info指令，查询指令相关信息，会要求您输入欲查询的名称。</li>
<li>F2 ：执行cat指令，列出文件内容。</li>
<li>F3 ：执行gitview指令，观看文件内容。</li>
<li>F4 ：执行vi指令，编辑文件内容。</li>
<li>F5 ：执行cp指令，复制文件或目录，会要求您输入目标文件或目录。</li>
<li>F6 ：执行mv指令，移动文件或目录，或是更改其名称，会要求您输入目标文件或目录。</li>
<li>F7 ：执行mkdir指令，建立目录。</li>
<li>F8 ：执行rm指令，删除文件或目录。</li>
<li>F9 ：执行make指令，批处理执行指令或编译程序时，会要求您输入相关命令。</li>
<li>F10 ：离开git文件管理员。</li>
</ul>
<h2 id="13-gitview"><a href="#13-gitview" class="headerlink" title="13. gitview"></a>13. gitview</h2><p>​        gitview命令用于观看文件的内容，它会同时显示十六进制和ASCII格式的字码。</p>
<h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><pre><code>gitview [-bchilv][文件]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-b 　单色模式，不使用ANSI控制码显示彩色。</li>
<li>-c 　彩色模式，使用ANSI控制码显示色彩。</li>
<li>-h 　在线帮助。</li>
<li>-i 　显示存放gitview程序的所在位置。</li>
<li>-l 　不使用先前的显示字符。</li>
<li>-v 　显示版本信息。</li>
</ul>
<h3 id="实例-9"><a href="#实例-9" class="headerlink" title="实例"></a>实例</h3><p>使用指令gitview以彩色模式观看文件”/home/ rootlocal/demo.txt”中的内容，输入如下命令：</p>
<pre><code>$ gitview -c /home/rootlocal/demo.txt      #使用gitview指令观看指定文件内容</code></pre><h2 id="14-indent"><a href="#14-indent" class="headerlink" title="14.indent"></a>14.indent</h2><p>​        indent命令用于调整C原始代码文件的格式。</p>
<p>indent可辨识C的原始代码文件，并加以格式化，以方便程序设计师阅读。</p>
<h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><pre><code>indent [参数][源文件] 或 indent [参数][源文件][-o 目标文件]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-bad或–blank-lines-after-declarations 　在声明区段或加上空白行。</li>
<li>-bap或–blank-lines-after-procedures 　在程序或加上空白行。</li>
<li>-bbb或–blank-lines-after-block-comments 　在注释区段后加上空白行。</li>
<li>-bc或–blank-lines-after-commas 　在声明区段中，若出现逗号即换行。</li>
<li>-bl或–braces-after-if-line 　if(或是else,for等等)与后面执行区段的”{“不同行，且”}”自成一行。</li>
<li>-bli&lt;缩排格数&gt;或–brace-indent&lt;缩排格数&gt; 　设置{ }缩排的格数。</li>
<li>-br或–braces-on-if-line 　if(或是else,for等等)与后面执行跛段的”{“不同行，且”}”自成一行。</li>
<li>-bs或–blank-before-sizeof 　在sizeof之后空一格。</li>
<li>-c&lt;栏数&gt;或–comment-indentation&lt;栏数&gt; 　将注释置于程序码右侧指定的栏位。</li>
<li>-cd&lt;栏数&gt;或–declaration-comment-column&lt;栏数&gt; 　将注释置于声明右侧指定的栏位。</li>
<li>-cdb或–comment-delimiters-on-blank-lines 　注释符号自成一行。</li>
<li>-ce或–cuddle-else 　将else置于”}”(if执行区段的结尾)之后。</li>
<li>-ci&lt;缩排格数&gt;或–continuation-indentation&lt;缩排格数&gt; 　叙述过长而换行时，指定换行后缩排的格数。</li>
<li>-cli&lt;缩排格数&gt;或–case-indentation-&lt;缩排格数&gt; 　使用case时，switch缩排的格数。</li>
<li>-cp&lt;栏数&gt;或-else-endif-column&lt;栏数&gt; 　将注释置于else与elseif叙述右侧定的栏位。</li>
<li>-cs或–space-after-cast 　在cast之后空一格。</li>
<li>-d&lt;缩排格数&gt;或-line-comments-indentation&lt;缩排格数&gt; 　针对不是放在程序码右侧的注释，设置其缩排格数。</li>
<li>-di&lt;栏数&gt;或–declaration-indentation&lt;栏数&gt; 　将声明区段的变量置于指定的栏位。</li>
<li>-fc1或–format-first-column-comments 　针对放在每行最前端的注释，设置其格式。</li>
<li>-fca或–format-all-comments 　设置所有注释的格式。</li>
<li>-gnu或–gnu-style 　指定使用GNU的格式，此为预设值。</li>
<li>-i&lt;格数&gt;或–indent-level&lt;格数&gt; 　设置缩排的格数。</li>
<li>-ip&lt;格数&gt;或–parameter-indentation&lt;格数&gt; 　设置参数的缩排格数。</li>
<li>-kr或–k-and-r-style 　指定使用Kernighan&amp;Ritchie的格式。</li>
<li>-lp或–continue-at-parentheses 　叙述过长而换行，且叙述中包含了括弧时，将括弧中的每行起始栏位内容垂直对其排列。</li>
<li>-nbad或–no-blank-lines-after-declarations 　在声明区段后不要加上空白行。</li>
<li>-nbap或–no-blank-lines-after-procedures 　在程序后不要加上空白行。</li>
<li>-nbbb或–no-blank-lines-after-block-comments 　在注释区段后不要加上空白行。</li>
<li>-nbc或–no-blank-lines-after-commas 　在声明区段中，即使出现逗号，仍旧不要换行。</li>
<li>-ncdb或–no-comment-delimiters-on-blank-lines 　注释符号不要自成一行。</li>
<li>-nce或–dont-cuddle-else 　不要将else置于”}”之后。</li>
<li>-ncs或–no-space-after-casts 　不要在cast之后空一格。</li>
<li>-nfc1或–dont-format-first-column-comments 　不要格式化放在每行最前端的注释。</li>
<li>-nfca或–dont-format-comments 　不要格式化任何的注释。</li>
<li>-nip或–no-parameter-indentation 　参数不要缩排。</li>
<li>-nlp或–dont-line-up-parentheses 　叙述过长而换行，且叙述中包含了括弧时，不用将括弧中的每行起始栏位垂直对其排列。</li>
<li>-npcs或–no-space-after-function-call-names 　在调用的函数名称之后，不要加上空格。</li>
<li>-npro或–ignore-profile 　不要读取indent的配置文件.indent.pro。</li>
<li>-npsl或–dont-break-procedure-type 　程序类型与程序名称放在同一行。</li>
<li>-nsc或–dont-star-comments 　注解左侧不要加上星号(*)。</li>
<li>-nsob或–leave-optional-semicolon 　不用处理多余的空白行。</li>
<li>-nss或–dont-space-special-semicolon 　若for或while区段仅有一行时，在分号前不加上空格。</li>
<li>-nv或–no-verbosity 　不显示详细的信息。</li>
<li>-orig或–original 　使用Berkeley的格式。</li>
<li>-pcs或–space-after-procedure-calls 　在调用的函数名称与”{“之间加上空格。</li>
<li>-psl或–procnames-start-lines 　程序类型置于程序名称的前一行。</li>
<li>-sc或–start-left-side-of-comments 　在每行注释左侧加上星号(*)。</li>
<li>-sob或–swallow-optional-blank-lines 　删除多余的空白行。</li>
<li>-ss或–space-special-semicolon 　若for或swile区段今有一行时，在分号前加上空格。</li>
<li>-st或–standard-output 　将结果显示在标准输出设备。</li>
<li>-T 　数据类型名称缩排。</li>
<li>-ts&lt;格数&gt;或–tab-size&lt;格数&gt; 　设置tab的长度。</li>
<li>-v或–verbose 　执行时显示详细的信息。</li>
<li>-version 　显示版本信息。</li>
</ul>
<h3 id="Indent代码格式化说明"><a href="#Indent代码格式化说明" class="headerlink" title="Indent代码格式化说明"></a>Indent代码格式化说明</h3><table>
<thead>
<tr>
<th align="left">使用的indent参数</th>
<th align="left">值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">–blank-lines-after-declarations</td>
<td align="left">bad</td>
<td align="left">变量声明后加空行</td>
</tr>
<tr>
<td align="left">–blank-lines-after-procedures</td>
<td align="left">bap</td>
<td align="left">函数结束后加空行</td>
</tr>
<tr>
<td align="left">–blank-lines-before-block-comments</td>
<td align="left">bbb</td>
<td align="left">块注释前加空行</td>
</tr>
<tr>
<td align="left">–break-before-boolean-operator</td>
<td align="left">bbo</td>
<td align="left">较长的行，在逻辑运算符前分行</td>
</tr>
<tr>
<td align="left">–blank-lines-after-commas</td>
<td align="left">nbc</td>
<td align="left">变量声明中，逗号分隔的变量不分行</td>
</tr>
<tr>
<td align="left">–braces-after-if-line</td>
<td align="left">bl</td>
<td align="left">“if”和”{“分做两行</td>
</tr>
<tr>
<td align="left">–brace-indent 0</td>
<td align="left">bli0</td>
<td align="left">“{“不继续缩进</td>
</tr>
<tr>
<td align="left">–braces-after-struct-decl-line</td>
<td align="left">bls</td>
<td align="left">定义结构，”struct”和”{“分行</td>
</tr>
<tr>
<td align="left">–comment-indentationn</td>
<td align="left">c33</td>
<td align="left">语句后注释开始于行33</td>
</tr>
<tr>
<td align="left">–declaration-comment-columnn</td>
<td align="left">cd33</td>
<td align="left">变量声明后注释开始于行33</td>
</tr>
<tr>
<td align="left">–comment-delimiters-on-blank-lines</td>
<td align="left">ncdb</td>
<td align="left">不将单行注释变为块注释</td>
</tr>
<tr>
<td align="left">–cuddle-do-while</td>
<td align="left">ncdw</td>
<td align="left">“do — while”的”while”和其前面的”}”另起一行</td>
</tr>
<tr>
<td align="left">–cuddle-else</td>
<td align="left">nce</td>
<td align="left">“else”和其前面的”}”另起一行</td>
</tr>
<tr>
<td align="left">–case-indentation 0</td>
<td align="left">cli0</td>
<td align="left">switch中的case语句所进0个空格</td>
</tr>
<tr>
<td align="left">–else-endif-columnn</td>
<td align="left">cp33</td>
<td align="left">#else, #endif后面的注释开始于行33</td>
</tr>
<tr>
<td align="left">–space-after-cast</td>
<td align="left">cs</td>
<td align="left">在类型转换后面加空格</td>
</tr>
<tr>
<td align="left">–line-comments-indentation n</td>
<td align="left">d0</td>
<td align="left">单行注释（不从1列开始的），不向左缩进</td>
</tr>
<tr>
<td align="left">–break-function-decl-args</td>
<td align="left">nbfda</td>
<td align="left">关闭：函数的参数一个一行</td>
</tr>
<tr>
<td align="left">–declaration-indentationn</td>
<td align="left">di2</td>
<td align="left">变量声明，变量开始于2行，即不必对齐</td>
</tr>
<tr>
<td align="left">–format-first-column-comments</td>
<td align="left">nfc1</td>
<td align="left">不格式化起于第一行的注释</td>
</tr>
<tr>
<td align="left">–format-all-comments</td>
<td align="left">nfca</td>
<td align="left">不开启全部格式化注释的开关</td>
</tr>
<tr>
<td align="left">–honour-newlines</td>
<td align="left">hnl</td>
<td align="left">Prefer to break long lines at the position of newlines in the input.</td>
</tr>
<tr>
<td align="left">–indent-leveln</td>
<td align="left">i4</td>
<td align="left">设置缩进多少字符，如果为tab的整数倍，用tab来缩进，否则用空格填充。</td>
</tr>
<tr>
<td align="left">–parameter-indentationn</td>
<td align="left">ip5</td>
<td align="left">旧风格的函数定义中参数说明缩进5个空格</td>
</tr>
<tr>
<td align="left">–line-length 75</td>
<td align="left">l75</td>
<td align="left">非注释行最长75</td>
</tr>
<tr>
<td align="left">–continue-at-parentheses</td>
<td align="left">lp</td>
<td align="left">续行从上一行出现的括号开始</td>
</tr>
<tr>
<td align="left">–space-after-procedure-calls</td>
<td align="left">pcs</td>
<td align="left">函数和”(“之间插入一个空格</td>
</tr>
<tr>
<td align="left">–space-after-parentheses</td>
<td align="left">nprs</td>
<td align="left">在”（”后”）”前不插入空格</td>
</tr>
<tr>
<td align="left">–procnames-start-lines</td>
<td align="left">psl</td>
<td align="left">将函数名和返回类型放在两行定义</td>
</tr>
<tr>
<td align="left">–space-after-for</td>
<td align="left">saf</td>
<td align="left">for后面有空格</td>
</tr>
<tr>
<td align="left">–space-after-if</td>
<td align="left">sai</td>
<td align="left">if后面有空格</td>
</tr>
<tr>
<td align="left">–space-after-while</td>
<td align="left">saw</td>
<td align="left">while后面有空格</td>
</tr>
<tr>
<td align="left">–start-left-side-of-comments</td>
<td align="left">nsc</td>
<td align="left">不在生成的块注释中加*</td>
</tr>
<tr>
<td align="left">–swallow-optional-blank-lines</td>
<td align="left">nsob</td>
<td align="left">不去掉可添加的空行</td>
</tr>
<tr>
<td align="left">–space-special-semicolon</td>
<td align="left">nss</td>
<td align="left">一行的for或while语句，在”;”前不加空。</td>
</tr>
<tr>
<td align="left">–tab-size</td>
<td align="left">ts4</td>
<td align="left">一个tab为4个空格（要能整除”-in”）</td>
</tr>
<tr>
<td align="left">–use-tabs</td>
<td align="left">ut</td>
<td align="left">使用tab来缩进</td>
</tr>
</tbody></table>
<h2 id="15-cut"><a href="#15-cut" class="headerlink" title="15.cut"></a>15.cut</h2><p>​        cut命令用于显示每行从开头算起 num1 到 num2 的文字。</p>
<h3 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h3><pre><code>cut  [-bn] [file]
cut [-c] [file]
cut [-df] [file]</code></pre><p><strong>使用说明:</strong></p>
<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>
<p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p>
<p><strong>参数:</strong></p>
<ul>
<li>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</li>
<li>-c ：以字符为单位进行分割。</li>
<li>-d ：自定义分隔符，默认为制表符。</li>
<li>-f ：与-d一起使用，指定显示哪个区域。</li>
<li>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br>范围之内，该字符将被写出；否则，该字符将被排除</li>
</ul>
<h3 id="实例-10"><a href="#实例-10" class="headerlink" title="实例"></a>实例</h3><p>当你执行who命令时，会输出类似如下的内容：</p>
<pre><code>$ who
rocrocket :0           2009-01-08 11:07
rocrocket pts/0        2009-01-08 11:23 (:0.0)
rocrocket pts/1        2009-01-08 14:15 (:0.0)</code></pre><p>如果我们想提取每一行的第3个字节，就这样：</p>
<pre><code>$ who|cut -b 3
c
c</code></pre><h2 id="16-ln"><a href="#16-ln" class="headerlink" title="16.ln"></a>16.ln</h2><p>​        ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>
<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<h3 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h3><pre><code> ln [参数][源文件或目录][目标文件或目录]</code></pre><p>其中参数的格式为</p>
<p>[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p>
<p>[–help] [–version] [–]</p>
<p><strong>命令功能</strong> :<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>
<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p><strong>软链接</strong>：</p>
<ul>
<li>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li>
<li>2.软链接可以 跨文件系统 ，硬链接不可以</li>
<li>3.软链接可以对一个不存在的文件名进行链接</li>
<li>4.软链接可以对目录进行链接</li>
</ul>
<p><strong>硬链接</strong>：</p>
<ul>
<li>1.硬链接，以文件副本的形式存在。但不占用实际空间。</li>
<li>2.不允许给目录创建硬链接</li>
<li>3.硬链接只有在同一个文件系统中才能创建</li>
</ul>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p><strong>必要参数</strong>：</p>
<ul>
<li>-b 删除，覆盖以前建立的链接</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-f 强制执行</li>
<li>-i 交互模式，文件存在则提示用户是否覆盖</li>
<li>-n 把符号链接视为一般目录</li>
<li>-s 软链接(符号链接)</li>
<li>-v 显示详细的处理过程</li>
</ul>
<p><strong>选择参数</strong>：</p>
<ul>
<li>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”</li>
<li>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息</li>
</ul>
<h3 id="实例-11"><a href="#实例-11" class="headerlink" title="实例"></a>实例</h3><p>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效：</p>
<pre><code>ln -s log2013.log link2013</code></pre><p>输出：</p>
<pre><code>[root@localhost test]# ll
-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log
[root@localhost test]# ln -s log2013.log link2013
[root@localhost test]# ll
lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log
-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</code></pre><p>给文件创建硬链接，为log2013.log创建硬链接ln2013，log2013.log与ln2013的各项属性相同</p>
<pre><code>ln log2013.log ln2013</code></pre><p>输出：</p>
<pre><code>[root@localhost test]# ll
lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log
-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log
[root@localhost test]# ln log2013.log ln2013
[root@localhost test]# ll
lrwxrwxrwx 1 root root     11 12-07 16:01 link2013 -&gt; log2013.log
-rw-r--r-- 2 root bin      61 11-13 06:03 ln2013
-rw-r--r-- 2 root bin      61 11-13 06:03 log2013.log</code></pre><h2 id="17-less"><a href="#17-less" class="headerlink" title="17.less"></a>17.less</h2><p>​        less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><pre><code>less [参数] 文件 </code></pre><p><strong>参数说明</strong>：</p>
<ul>
<li>-b &lt;缓冲区大小&gt; 设置缓冲区的大小</li>
<li>-e 当文件显示结束后，自动离开</li>
<li>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li>
<li>-g 只标志最后搜索的关键词</li>
<li>-i 忽略搜索时的大小写</li>
<li>-m 显示类似more命令的百分比</li>
<li>-N 显示每行的行号</li>
<li>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</li>
<li>-Q 不使用警告音</li>
<li>-s 显示连续空行为一行</li>
<li>-S 行过长时间将超出部分舍弃</li>
<li>-x &lt;数字&gt; 将”tab”键显示为规定的数字空格</li>
<li>/字符串：向下搜索”字符串”的功能</li>
<li>?字符串：向上搜索”字符串”的功能</li>
<li>n：重复前一个搜索（与 / 或 ? 有关）</li>
<li>N：反向重复前一个搜索（与 / 或 ? 有关）</li>
<li>b 向后翻一页</li>
<li>d 向后翻半页</li>
<li>h 显示帮助界面</li>
<li>Q 退出less 命令</li>
<li>u 向前滚动半页</li>
<li>y 向前滚动一行</li>
<li>空格键 滚动一页</li>
<li>回车键 滚动一行</li>
<li>[pagedown]： 向下翻动一页</li>
<li>[pageup]： 向上翻动一页</li>
</ul>
<h3 id="实例-12"><a href="#实例-12" class="headerlink" title="实例"></a>实例</h3><p>1、查看文件</p>
<pre><code>less log2013.log</code></pre><p>2、ps查看进程信息并通过less分页显示</p>
<pre><code>ps -ef |less</code></pre><p>3、查看命令历史使用记录并通过less分页显示</p>
<pre><code>[root@localhost test]# history | less
22  scp -r tomcat6.0.32 root@192.168.120.203:/opt/soft
23  cd ..
24  scp -r web root@192.168.120.203:/opt/
25  cd soft
26  ls
……省略……</code></pre><p>4、浏览多个文件</p>
<pre><code>less log2013.log log2014.log</code></pre><p>说明：<br>输入 ：n后，切换到 log2014.log<br>输入 ：p 后，切换到log2013.log</p>
<h3 id="附加备注"><a href="#附加备注" class="headerlink" title="附加备注"></a>附加备注</h3><p>1.全屏导航</p>
<ul>
<li>ctrl + F - 向前移动一屏</li>
<li>ctrl + B - 向后移动一屏</li>
<li>ctrl + D - 向前移动半屏</li>
<li>ctrl + U - 向后移动半屏</li>
</ul>
<p>2.单行导航</p>
<ul>
<li>j - 向前移动一行</li>
<li>k - 向后移动一行</li>
</ul>
<p>3.其它导航</p>
<ul>
<li>G - 移动到最后一行</li>
<li>g - 移动到第一行</li>
<li>q / ZZ - 退出 less 命令</li>
</ul>
<p>4.其它有用的命令</p>
<ul>
<li>v - 使用配置的编辑器编辑当前文件</li>
<li>h - 显示 less 的帮助文档</li>
<li>&amp;pattern - 仅显示匹配模式的行，而不是整个文件</li>
</ul>
<p>5.标记导航</p>
<p>当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：</p>
<ul>
<li>ma - 使用 a 标记文本的当前位置</li>
<li>‘a - 导航到标记 a 处</li>
</ul>
<h2 id="18-locate"><a href="#18-locate" class="headerlink" title="18.locate"></a>18.locate</h2><p>​        locate命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。</p>
<p>一般情况我们只需要输入 <strong>locate your_file_name</strong> 即可查找指定文件。</p>
<h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><pre><code>locate [-d ][--help][--version][范本样式...]</code></pre><p><strong>参数：</strong></p>
<ul>
<li>-d或–database= 配置locate指令使用的数据库。locate指令预设的数据库位于/var/lib/slocate目录里，文档名为slocate.db，您可使用 这个参数另行指定。</li>
<li>–help 　在线帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例-13"><a href="#实例-13" class="headerlink" title="实例"></a>实例</h3><p>查找passwd文件，输入以下命令：</p>
<pre><code>locate passwd</code></pre><h3 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h3><p>locate与find 不同: find 是去硬盘找，locate 只在/var/lib/slocate资料库中找。</p>
<p>locate的速度比find快，它并不是真的查找，而是查数据库，一般文件数据库在/var/lib/slocate/slocate.db中，所以locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为：</p>
<pre><code>locate -u </code></pre><h2 id="19-lsattr命令"><a href="#19-lsattr命令" class="headerlink" title="19.lsattr命令"></a>19.lsattr命令</h2><p>​        lsattr命令用于显示文件属性。</p>
<p>用chattr执行改变文件或目录的属性，可执行lsattr指令查询其属性。</p>
<h3 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h3><pre><code>lsattr [-adlRvV][文件或目录...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-a 　显示所有文件和目录，包括以”.”为名称开头字符的额外内建，现行目录”.”与上层目录”..”。</li>
<li>-d 　显示，目录名称，而非其内容。</li>
<li>-l 　此参数目前没有任何作用。</li>
<li>-R 　递归处理，将指定目录下的所有文件及子目录一并处理。</li>
<li>-v 　显示文件或目录版本。</li>
<li>-V 　显示版本信息。</li>
</ul>
<h3 id="实例-14"><a href="#实例-14" class="headerlink" title="实例"></a>实例</h3><p>1、用chattr命令防止系统中某个关键文件被修改：</p>
<pre><code># chattr +i /etc/resolv.conf</code></pre><p>然后用mv /etc/resolv.conf等命令操作于该文件，都是得到Operation not permitted 的结果。</p>
<p>vim编辑该文件时会提示W10: Warning: Changing a readonly file错误。要想修改此文件就要把i属性去掉：</p>
<pre><code>chattr -i /etc/resolv.conf</code></pre><p>使用 lsattr 命令来显示文件属性：</p>
<pre><code># lsattr /etc/resolv.conf</code></pre><p>输出结果为:</p>
<pre><code>----i-------- /etc/resolv.conf</code></pre><p>2、让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：</p>
<pre><code># chattr +a /var/log/messages</code></pre><h2 id="20-mattrib"><a href="#20-mattrib" class="headerlink" title="20.mattrib"></a>20.mattrib</h2><p>​        mattrib命令用来变更或显示MS-DOS文件的属性。</p>
<p>mattrib为mtools工具指令，模拟MS-DOS的attrib指令，可变更MS-DOS文件的属性。</p>
<h3 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h3><pre><code>mattrib [-a|+a] [-h|+h] [-r|+r] [-s|+s] [-/] [-X] msdosfile [ msdosfiles ... ]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-a/+a 除去/设定备份属性。</li>
<li>-h/+h 除去/设定隐藏属性。</li>
<li>-r/+r 除去/设定唯读属性。</li>
<li>-s/+s 除去/设定系统属性。</li>
<li>-/ 递回的处理包含所有子目录下的档案。</li>
<li>-X 以较短的格式输出结果。</li>
</ul>
<h3 id="实例-15"><a href="#实例-15" class="headerlink" title="实例"></a>实例</h3><p>列出 A 槽 MSDOS 格式磁片上所有文件的属性。</p>
<pre><code>mattrib a: </code></pre><p>除去 A 槽磁片上 msdos.sys 档案的隐藏、系统与唯读属性。</p>
<pre><code>mattrib -h -s -r a:msdos.sys</code></pre><p>除去 A 槽磁片上包含子目录下所有档案的唯读属性。</p>
<pre><code>mattrib -r -/ a:*.*</code></pre><h2 id="21-mc"><a href="#21-mc" class="headerlink" title="21.mc"></a>21.mc</h2><p>​         mc命令用于提供一个菜单式的文件管理程序。</p>
<p>执行mc之后，将会看到菜单式的文件管理程序，共分成４个部分。</p>
<h3 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h3><pre><code>mc [-abcdfhkPstuUVx][-C &lt;参数&gt;][-l &lt;文件&gt;][-v &lt;文件&gt;][目录]</code></pre><p>　　<strong>参　　数</strong>：</p>
<ul>
<li>-a 　当mc程序画线时不用绘图字符画线。</li>
<li>-b 　使用单色模式显示。</li>
<li>-c 　使用彩色模式显示。</li>
<li>-C&lt;参数&gt; 　指定显示的颜色。</li>
<li>-d 　不使用鼠标。</li>
<li>-f 　显示mc函数库所在的目录。</li>
<li>-h 　显示帮助。</li>
<li>-k 　重设softkeys成预设置。</li>
<li>-l&lt;文件&gt; 　在指定文件中保存ftpfs对话窗的内容。</li>
<li>-P 　程序结束时，列出最后的工作目录。</li>
<li>-s 　用慢速的终端机模式显示，在这模式下将减少大量的绘图及文字显示。</li>
<li>-t 　使用TEMPCAP变量设置终端机，而不使用预设置。</li>
<li>-u 　不用目前的shell程序。</li>
<li>-U 　使用目前的shell程序。</li>
<li>-v&lt;文件&gt; 　使用mc的内部编辑器来显示指定的文件。</li>
<li>-V 　显示版本信息。</li>
<li>-x 　指定以xterm模式显示。</li>
</ul>
<h3 id="Linux-MC-相关操作"><a href="#Linux-MC-相关操作" class="headerlink" title="Linux MC 相关操作"></a>Linux MC 相关操作</h3><table>
<thead>
<tr>
<th align="left">命令按键</th>
<th align="left">描 述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">F9 or Esc+9</td>
<td align="left">激活菜单栏</td>
</tr>
<tr>
<td align="left">Tab</td>
<td align="left">在两个窗口间移动</td>
</tr>
<tr>
<td align="left">F10 or Esc+0</td>
<td align="left">退出MC</td>
</tr>
<tr>
<td align="left">Control-Enter or Alt-Enter</td>
<td align="left">可以将文件名拷贝到命令行</td>
</tr>
<tr>
<td align="left">F1 or Esc+1</td>
<td align="left">打开帮助页面</td>
</tr>
</tbody></table>
<p>虽然MC很好用，不过我还是建议大家使用命令行工具！</p>
<h2 id="22-mdel"><a href="#22-mdel" class="headerlink" title="22.mdel"></a>22.mdel</h2><p>​        mdel命令用来删除 MSDOS 格式的档案。</p>
<p>在删除只读之前会有提示信息产生。</p>
<h3 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h3><pre><code>mdel [-v] msdosfile [ msdosfiles ... ]</code></pre><p><strong>参数：</strong></p>
<ul>
<li>-v 显示更多的讯息。</li>
</ul>
<h3 id="实例-16"><a href="#实例-16" class="headerlink" title="实例"></a>实例</h3><p>将 A 槽磁片根目录中的 autoexec.bat 删除。</p>
<pre><code>mdel a:autoexec.bat . </code></pre><h2 id="23-mdir"><a href="#23-mdir" class="headerlink" title="23.mdir"></a>23.mdir</h2><p>​        mdir命令用于显示MS-DOS目录。</p>
<p>mdir为mtools工具指令，模拟MS-DOS的dir指令，可显示MS-DOS文件系统中的目录内容。</p>
<h3 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h3><pre><code>mdir [-afwx/][目录]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-/ 显示目录下所有子目录与文件。</li>
<li>-a 　显示隐藏文件。</li>
<li>-f 　不显示磁盘所剩余的可用空间。</li>
<li>-w 　仅显示目录或文件名称，并以横排方式呈现，以便一次能显示较多的目录或文件。</li>
<li>-X 　仅显示目录下所有子目录与文件的完整路径，不显示其他信息。</li>
</ul>
<h3 id="实例-17"><a href="#实例-17" class="headerlink" title="实例"></a>实例</h3><p>显示a盘中的内容</p>
<pre><code>$ mdir -/ a:\*   </code></pre><p>以上命令执行后，mdir将显示指定盘”a:&quot;中的所有子目录及其中的文件信息，如下所示：</p>
<pre><code>Volume in drive A has no label  #加载信息  
Volume Serial Number is 13D2~055C  
Directory for A:\                   #以下为目录信息  
./TEST &lt;DIR&gt; 2011-08-23 16:59     
#显示格式为文件名，目录大小，修改时间  
AUTORUN.INF 265 2011-08-23 16:53  
AUTORUN.BAT 43 2011-08-23 16:56  
3 files 308 bytes               #统计总大小  
724 325 bytes free              #剩余空间  </code></pre><h2 id="24-mktemp"><a href="#24-mktemp" class="headerlink" title="24.mktemp"></a>24.mktemp</h2><p>​         mktemp命令用于建立暂存文件。</p>
<p>mktemp建立的一个暂存文件，供shell script使用。</p>
<h3 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h3><pre><code>mktemp [-qu][文件名参数]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-q 　执行时若发生错误，不会显示任何信息。</li>
<li>-u 　暂存文件会在mktemp结束前先行删除。</li>
<li>[文件名参数] 　文件名参数必须是以”自订名称.XXXXXX”的格式。</li>
</ul>
<h3 id="实例-18"><a href="#实例-18" class="headerlink" title="实例"></a>实例</h3><p>使用mktemp 命令生成临时文件时，文件名参数应当以”文件名.XXXX”的形式给出，mktemp 会根据文件名参数建立一个临时文件。在命令行提示符输入如下命令：</p>
<pre><code>mktemp tmp.xxxx #生成临时文件 </code></pre><p>使用该命令后，可使用dir 或ls看当前目录，得到如下结果：</p>
<pre><code>cmd@cmd-desktop:~$ mktemp tmp.xxxx #生成临时文件  
cmd@cmd-desktop:~$dir #查看当前目录  
file test testfile testfile1 tmp.3847 #生成了tmp.3847 </code></pre><p>由此可见，生成的临时文件为tmp.3847，其中，文件名参数中的”XXXX”被4 个随机产生的字符所取代。</p>
<h2 id="25-more"><a href="#25-more" class="headerlink" title="25.more"></a>25.more</h2><p>​         more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p>
<h3 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h3><pre><code>more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-num 一次显示的行数</li>
<li>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声</li>
<li>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</li>
<li>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）</li>
<li>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</li>
<li>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料</li>
<li>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</li>
<li>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</li>
<li>+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</li>
<li>+num 从第 num 行开始显示</li>
<li>fileNames 欲显示内容的文档，可为复数个数</li>
</ul>
<h3 id="实例-19"><a href="#实例-19" class="headerlink" title="实例"></a>实例</h3><p>逐页显示 testfile 文档内容，如有连续两行以上空白行则以一行空白行显示。</p>
<pre><code>more -s testfile</code></pre><p>从第 20 行开始显示 testfile 之文档内容。</p>
<pre><code>more +20 testfile</code></pre><h3 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h3><ul>
<li>Enter 向下n行，需要定义。默认为1行</li>
<li>Ctrl+F 向下滚动一屏</li>
<li>空格键 向下滚动一屏</li>
<li>Ctrl+B 返回上一屏</li>
<li>= 输出当前行的行号</li>
<li>：f 输出文件名和当前行的行号</li>
<li>V 调用vi编辑器</li>
<li>!命令 调用Shell，并执行命令</li>
<li>q 退出more</li>
</ul>
<h2 id="26-mmove"><a href="#26-mmove" class="headerlink" title="26.mmove"></a>26.mmove</h2><p>​        mmove命令用于在MS-DOS文件系统中，移动文件或目录，或更改名称。</p>
<p>mmove为mtools工具命令，模拟MS-DOS的move命令，可在MS-DOS文件系统中移动现有的文件或目录，或是更改现有文件或目录的名称。</p>
<h3 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h3><pre><code>mmove [源文件或目录...][目标文件或目录]</code></pre><p><strong>参数说明:</strong></p>
<ul>
<li><p>[源文件或目录…]: 执行操作的源文件或目录路径</p>
</li>
<li><p>[目标文件或目录]: 执行操作后的目标文件或目录路径</p>
</li>
</ul>
<h3 id="实例-20"><a href="#实例-20" class="headerlink" title="实例"></a>实例</h3><p>使用指令mmove将文件”autorun.bat”移动到目录”test”中，输入如下命令：</p>
<pre><code>$ mmove autorun.bat test        #移动文件到目录test中 </code></pre><p>以上命令执行以后，指令mmove会将文件”autorun.bat”移动到指定目录”test”中。</p>
<p>注意：用户可以使用mdir指令查看移动后的文件或目录信息。</p>
<h2 id="27-mread"><a href="#27-mread" class="headerlink" title="27.mread"></a>27.mread</h2><p>​        mread命令用于将MS-DOS文件复制到Linux/Unix的目录中。</p>
<p>mread为mtools工具命令，可将MS-DOS文件复制到Linux的文件系统中。这个命令目前已经不常用，一般都使用mcopy命令来代替。</p>
<h3 id="语法-25"><a href="#语法-25" class="headerlink" title="语法"></a>语法</h3><pre><code>mread [MS-DOS文件...][Linux文件或目录]</code></pre><p><strong>参数说明:</strong></p>
<ul>
<li><p>[MS-DOS文件…]: 执行操作的DOS源文件或目录路径</p>
</li>
<li><p>[Linux文件或目录]: 执行操作后的Linux目标文件或目录路径</p>
</li>
</ul>
<h3 id="实例-21"><a href="#实例-21" class="headerlink" title="实例"></a>实例</h3><p>使用指令mread将盘”a:&quot;中的所有内容复制到当前工作目录下，输入如下命令：</p>
<pre><code>$ mread a:\* ./     #将a盘上的所有文件复制到当前工作目录 </code></pre><p>执行该命令前，可以先使用mdir命令查看原来的目录结构。执行mread之后，可使用ls命令再次查看复制之后的文件结构，结果如下所示：</p>
<pre><code>$ mdir -/ a:\*      #查看a盘中的文件  
Volume in drive A has no label          #加载信息  
Volume Serial Number is 13D2~055C  
Directory for A:/                   #以下为目录信息  
./TEST &lt;DIR&gt; 2011-08-23 16:59         
#显示格式为文件名，目录大小，修改时间  
AUTORUN.INF 265 2011-08-23 16:53  
AUTORUN.BAT 43 2011-08-23 16:56  
3 files 308 bytes                       #统计总大小  
724 325 bytes free                  #剩余空间  
$ mread A:\* ./     #将a盘上所有文件复制到当前工作目录  
$ ls                                    #查看文件或子目录信息  
TEST AUTORUN.INF AUTORUN.BAT            #显示复制后的内容  </code></pre><h2 id="28-mren"><a href="#28-mren" class="headerlink" title="28.mren"></a>28.mren</h2><p>​        mren命令用于更改MS-DOS文件或目录的名称，或是移动文件或目录。</p>
<p>mren为MS-DOS工具指令，与DOS下的ren指令相似，可以实现更改MS-DOS文件或目录名称。</p>
<p>源文件必须是磁盘上已经存在的文件，若忽略盘符及路径，则表示当前盘及当前目录的文件。</p>
<p>新文件名是所要更换的文件名称。新文件名称前不可以加与源文件不同的盘符及路径，因为该命令只能更改同一盘上的文件名称。</p>
<h3 id="语法-26"><a href="#语法-26" class="headerlink" title="语法"></a>语法</h3><pre><code>mren [源文件或目录...][目标文件或目录]</code></pre><p><strong>参数说明：</strong></p>
<ul>
<li>[源文件或目录…]： 执行操作的源文件名或者源文件路径</li>
<li></li>
<li>[目标文件或目录]： 执行操作的目标文件名或者目标文件路径</li>
</ul>
<h3 id="实例-22"><a href="#实例-22" class="headerlink" title="实例"></a>实例</h3><p>使用指令mren将a盘下的文件”autorun.bat”的文件名修改为”auto.bat”，输入如下命令：</p>
<pre><code>$ mren a:\autorun.bat auto.bat  
#将文件autorun.bat重命名为auto.bat  </code></pre><p>使用该命令前后使用mdir命令查看并对比，得到结果如下：</p>
<pre><code>$ mdir -/ a:\*                  #查看a盘中的文件  
Volume in drive A has no label  #加载信息  
Volume Serial Number is 13D2~055C  
Directory for A:\                   #以下为目录信息  
./TEST &lt;DIR&gt; 2011-08-23 16:59       #文件名，目录大小，修改时间  
AUTORUN.BAT 43 2011-08-23 16:56  
3 files 308 bytes                   #统计总大小  
724 325 bytes free              #剩余空间  
#将文件autorun.bat重命名为auto.bat  
$ mren a:\autorun.bat auto.bat        
$ mdir -/ a:\*                  #再次查看a盘中文件  
Volume in drive A has no label      #加载信息  
Volume Serial Number is 13D2~055C  
Directory for A:\                   #以下为目录信息  
./TEST &lt;DIR&gt; 2011-08-23 16:59       #文件名目录大小 修改时间  
#文件名被改为auto.bat，修改时间改为当前系统时间  
AUTO.BAT 43 2011-08-23 16:56          
3 files 308 bytes                   #统计总大小  
724 325 bytes free              #剩余空间  </code></pre><h2 id="29-mtools"><a href="#29-mtools" class="headerlink" title="29.mtools"></a>29.mtools</h2><p>​         mtools命令用于显示mtools支持的指令。</p>
<p>mtools为MS-DOS文件系统的工具程序，可模拟许多MS-DOS的指令。这些指令都是mtools的符号连接，因此会有一些共同的特性。</p>
<h3 id="语法-27"><a href="#语法-27" class="headerlink" title="语法"></a>语法</h3><pre><code>mtools</code></pre><p><strong>参数说明</strong>：</p>
<ul>
<li>-a 　长文件名重复时自动更改目标文件的长文件名。</li>
<li>-A 　短文件名重复但长文件名不同时自动更改目标文件的短文件名。</li>
<li>-o 　长文件名重复时，将目标文件覆盖现有的文件。</li>
<li>-O 　短文件名重复但长文件名不同时，将目标文件覆盖现有的文件。</li>
<li>-r 　长文件名重复时，要求用户更改目标文件的长文件名。</li>
<li>-R 　短文件名重复但长文件名不同时，要求用户更改目标文件的短文件名。</li>
<li>-s 　长文件名重复时，则不处理该目标文件。</li>
<li>-S 　短文件名重复但长文件名不同时，则不处理该目标文件。</li>
<li>-v 　执行时显示详细的说明。</li>
<li>-V 　显示版本信息。</li>
</ul>
<h3 id="实例-23"><a href="#实例-23" class="headerlink" title="实例"></a>实例</h3><p>显示 mtools软件包所支持的MS-DOS命令。</p>
<p>在命令提示符中直接输入mtools，可显示其所支持的MS-DOS命令，如下所示：</p>
<pre><code>$ mtools #显示所支持的MS-DOS命令  
Supported commands: #命令列表  
mattrib, mbadblocks, mcat, mcd, mclasserase, mcopy, mdel, mdeltree  
mdir, mdoctorfat, mdu, mformat, minfo, mlabel, mmd, mmount  
mpartition, mrd, mread, mmove, mren, mshowfat, mtoolstest, mtype  
mwrite, mzip </code></pre><h2 id="30-mtoolstest"><a href="#30-mtoolstest" class="headerlink" title="30.mtoolstest"></a>30.mtoolstest</h2><p>​        mtoolstest命令用于测试并显示mtools的相关设置。</p>
<p>mtoolstest为mtools的工具指令，可读取与分析的mtools的配置文件，并在屏幕上显示结果。</p>
<h3 id="语法-28"><a href="#语法-28" class="headerlink" title="语法"></a>语法</h3><pre><code>mtoolstest</code></pre><h3 id="实例-24"><a href="#实例-24" class="headerlink" title="实例"></a>实例</h3><p>在命令行中直接输入mtoolstest，即可显示mtools的软件包当前的配置信息，结果如下：</p>
<pre><code>$ mtoolstest＃显示mtools软件包当前的配置信息  
驱动器J：#mtools软件包当前的配置信息列表  
＃fn = 0 mode = 0 builtin  
file =“/ dev / sdb4”fat_bits = 16 
tracks = 0 heads = 0 sector = 0 hidden = 0 
偏移量=为0x0 
分区= 0 
mformat_only  
开车Z：  
＃fn = 0 mode = 0 builtin  
file =“/ dev / sdb4”fat_bits = 16 
tracks = 0 heads = 0 sector = 0 hidden = 0 
偏移量=为0x0 
分区= 0 
mformat_only  
开车X：  
＃fn = 0 mode = 0 builtin  
file =“$ DISPLAY”fat_bits = 0 
tracks = 0 heads = 0 sector = 0 hidden = 0 
偏移量=为0x0 
分区= 0 
驾驶A：  
＃fn = 2 mode = 128在/etc/mtools.conf中定义  
file =“/ dev / fd0”fat_bits = 0 
tracks = 0 heads = 0 sector = 0 hidden = 0 
偏移量=为0x0 
分区= 0 
独家  
开车B：  
＃fn = 2 mode = 128在/etc/mtools.conf中定义  
file =“/ dev / fd1”fat_bits = 0 
tracks = 0 heads = 0 sector = 0 hidden = 0 
偏移量=为0x0 
分区= 0 
独家  
驾驶M：  
＃fn = 2 mode = 0在/etc/mtools.conf中定义  
file =“/ var / lib / dosemu / hdimage.first”fat_bits = 0 
tracks = 0 heads = 0 sector = 0 hidden = 0 
偏移量= 0x80的 
分区= 1 
开车N：  
＃fn = 2 mode = 0在/etc/mtools.conf中定义  
file =“/ var / lib / dosemu / fdimage”fat_bits = 0 
tracks = 0 heads = 0 sector = 0 hidden = 0 
偏移量=为0x0 
分区= 0 
mtools_fat_compatibility = 0 
mtools_skip_check = 0 
mtools_lower_case = 0 </code></pre><h2 id="31-mv"><a href="#31-mv" class="headerlink" title="31.mv"></a>31.mv</h2><p>​        mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<h3 id="语法-29"><a href="#语法-29" class="headerlink" title="语法"></a>语法</h3><pre><code>mv [options] source dest
mv [options] source... directory</code></pre><p><strong>参数说明</strong>：</p>
<ul>
<li>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;</li>
<li>-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;</li>
</ul>
<p>mv参数设置与运行结果</p>
<table>
<thead>
<tr>
<th align="left">命令格式</th>
<th align="left">运行结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mv 文件名 文件名</td>
<td align="left">将源文件名改为目标文件名</td>
</tr>
<tr>
<td align="left">mv 文件名 目录名</td>
<td align="left">将文件移动到目标目录</td>
</tr>
<tr>
<td align="left">mv 目录名 目录名</td>
<td align="left">目标目录已存在，将源目录 移动到目标目录；目标 目录不存在则改名</td>
</tr>
<tr>
<td align="left">mv 目录名 文件名</td>
<td align="left">出错</td>
</tr>
</tbody></table>
<h3 id="实例-25"><a href="#实例-25" class="headerlink" title="实例"></a>实例</h3><p>将文件 aaa 更名为 bbb :</p>
<pre><code>mv aaa bbb</code></pre><p>将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs。</p>
<pre><code>mv info/ logs </code></pre><p>再如将/usr/student下的所有文件和目录移到当前目录下，命令行为：</p>
<pre><code>$ mv /usr/student/*  . </code></pre><h2 id="32-od"><a href="#32-od" class="headerlink" title="32.od"></a>32.od</h2><p>​         od命令用于输出文件内容。</p>
<p>od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来。</p>
<h3 id="语法-30"><a href="#语法-30" class="headerlink" title="语法"></a>语法</h3><pre><code>od [-abcdfhilovx][-A &lt;字码基数&gt;][-j &lt;字符数目&gt;][-N &lt;字符数目&gt;][-s &lt;字符串字符数&gt;][-t &lt;输出格式&gt;][-w &lt;每列字符数&gt;][--help][--version][文件...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-a 　此参数的效果和同时指定”-ta”参数相同。</li>
<li>-A&lt;字码基数&gt; 　选择要以何种基数计算字码。</li>
<li>-b 　此参数的效果和同时指定”-toC”参数相同。</li>
<li>-c 　此参数的效果和同时指定”-tC”参数相同。</li>
<li>-d 　此参数的效果和同时指定”-tu2”参数相同。</li>
<li>-f 　此参数的效果和同时指定”-tfF”参数相同。</li>
<li>-h 　此参数的效果和同时指定”-tx2”参数相同。</li>
<li>-i 　此参数的效果和同时指定”-td2”参数相同。</li>
<li>-j&lt;字符数目&gt;或–skip-bytes=&lt;字符数目&gt; 　略过设置的字符数目。</li>
<li>-l 　此参数的效果和同时指定”-td4”参数相同。</li>
<li>-N&lt;字符数目&gt;或–read-bytes=&lt;字符数目&gt; 　到设置的字符数目为止。</li>
<li>-o 　此参数的效果和同时指定”-to2”参数相同。</li>
<li>-s&lt;字符串字符数&gt;或–strings=&lt;字符串字符数&gt; 　只显示符合指定的字符数目的字符串。</li>
<li>-t&lt;输出格式&gt;或–format=&lt;输出格式&gt; 　设置输出格式。</li>
<li>-v或–output-duplicates 　输出时不省略重复的数据。</li>
<li>-w&lt;每列字符数&gt;或–width=&lt;每列字符数&gt; 　设置每列的最大字符数。</li>
<li>-x 　此参数的效果和同时指定”-h”参数相同。</li>
<li>–help 　在线帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例-26"><a href="#实例-26" class="headerlink" title="实例"></a>实例</h3><p>创建 tmp 文件：</p>
<pre><code>$ echo abcdef g &gt; tmp
$ cat tmp
abcdef g</code></pre><p>使用 od 命令：</p>
<pre><code>$ od -b tmp
0000000 141 142 143 144 145 146 040 147 012
0000011</code></pre><p>使用单字节八进制解释进行输出，注意左侧的默认地址格式为八字节:</p>
<pre><code>$ od -c tmp
0000000   a   b   c   d   e   f       g  \n
0000011</code></pre><p>使用ASCII码进行输出，注意其中包括转义字符</p>
<pre><code>$ od -t d1 tmp
0000000   97   98   99  100  101  102   32  103   10
0000011</code></pre><p>使用单字节十进制进行解释</p>
<pre><code>$ od -A d -c tmp
0000000   a   b   c   d   e   f       g  \n
0000009</code></pre><h2 id="33-paste"><a href="#33-paste" class="headerlink" title="33.paste"></a>33.paste</h2><p>​         paste命令用于合并文件的列。</p>
<p>paste指令会把每个文件以列对列的方式，一列列地加以合并。</p>
<h3 id="语法-31"><a href="#语法-31" class="headerlink" title="语法"></a>语法</h3><pre><code>paste [-s][-d &lt;间隔字符&gt;][--help][--version][文件...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-d&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt; 　用指定的间隔字符取代跳格字符。</li>
<li>-s或–serial 　串列进行而非平行处理。</li>
<li>–help 　在线帮助。</li>
<li>–version 　显示帮助信息。</li>
<li>[文件…] 指定操作的文件路径</li>
</ul>
<h3 id="实例-27"><a href="#实例-27" class="headerlink" title="实例"></a>实例</h3><p>使用paste指令将文件”file”、”testfile”、”testfile1”进行合并，输入如下命令：</p>
<pre><code>paste file testfile testfile1 #合并指定文件的内容 </code></pre><p>但是，在执行以上命令之前，首先使用”cat”指令对3个文件内容进行查看，显示如下所示：</p>
<pre><code>$ cat file                  #file文件的内容  
xiongdan 200  
lihaihui 233  
lymlrl 231  
$ cat testfile              #testfile文件的内容  
liangyuanm  ss  
$ cat testfile1             #testfile1文件的内容  
huanggai 56  
zhixi 73 </code></pre><p>当合并指令”$ paste file testfile testfile1”执行后，程序界面中将显示合并后的文件内容，如下所示：</p>
<pre><code>xiongdan 200  
lihaihui 233  
lymlrl 231  
liangyuanm  ss  
huanggai 56  
zhixi 73  </code></pre><p>若使用paste指令的参数”-s”，则可以将一个文件中的多行数据合并为一行进行显示。例如，将文件”file”中的3行数据合并为一行数据进行显示，输入如下命令</p>
<pre><code>$ paste -s file             #合并指定文件的多行数据</code></pre><p>上面的命令执行后，显示的数据内容如下所示：</p>
<pre><code>xiongdan 200 lihaihui 233 lymlrl 231 </code></pre><p>注意：参数”-s”只是将testfile文件的内容调整显示方式，并不会改变原文件的内容格式。</p>
<h2 id="34-patch"><a href="#34-patch" class="headerlink" title="34.patch"></a>34.patch</h2><p>​         patch命令用于修补文件。</p>
<p>patch指令让用户利用设置修补文件的方式，修改，更新原始文件。倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行。如果配合修补文件的方式则能一次修补大批文件，这也是Linux系统核心的升级方法之一。</p>
<h3 id="语法-32"><a href="#语法-32" class="headerlink" title="语法"></a>语法</h3><pre><code>patch [-bceEflnNRstTuvZ][-B &lt;备份字首字符串&gt;][-d &lt;工作目录&gt;][-D &lt;标示符号&gt;][-F &lt;监别列数&gt;][-g &lt;控制数值&gt;][-i &lt;修补文件&gt;][-o &lt;输出文件&gt;][-p &lt;剥离层级&gt;][-r &lt;拒绝文件&gt;][-V &lt;备份方式&gt;][-Y &lt;备份字首字符串&gt;][-z &lt;备份字尾字符串&gt;][--backup-if -mismatch][--binary][--help][--nobackup-if-mismatch][--verbose][原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-b或–backup 　备份每一个原始文件。</li>
<li>-B&lt;备份字首字符串&gt;或–prefix=&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件名称前面的字首字符串，该字符串可以是路径名称。</li>
<li>-c或–context 　把修补数据解译成关联性的差异。</li>
<li>-d&lt;工作目录&gt;或–directory=&lt;工作目录&gt; 　设置工作目录。</li>
<li>-D&lt;标示符号&gt;或–ifdef=&lt;标示符号&gt; 　用指定的符号把改变的地方标示出来。</li>
<li>-e或–ed 　把修补数据解译成ed指令可用的叙述文件。</li>
<li>-E或–remove-empty-files 　若修补过后输出的文件其内容是一片空白，则移除该文件。</li>
<li>-f或–force 　此参数的效果和指定”-t”参数类似，但会假设修补数据的版本为新　版本。</li>
<li>-F&lt;监别列数&gt;或–fuzz&lt;监别列数&gt; 　设置监别列数的最大值。</li>
<li>-g&lt;控制数值&gt;或–get=&lt;控制数值&gt; 　设置以RSC或SCCS控制修补作业。</li>
<li>-i&lt;修补文件&gt;或–input=&lt;修补文件&gt; 　读取指定的修补文件。</li>
<li>-l或–ignore-whitespace 　忽略修补数据与输入数据的跳格，空格字符。</li>
<li>-n或–normal 　把修补数据解译成一般性的差异。</li>
<li>-N或–forward 　忽略修补的数据较原始文件的版本更旧，或该版本的修补数据已使　用过。</li>
<li>-o&lt;输出文件&gt;或–output=&lt;输出文件&gt; 　设置输出文件的名称，修补过的文件会以该名称存放。</li>
<li>-p&lt;剥离层级&gt;或–strip=&lt;剥离层级&gt; 　设置欲剥离几层路径名称。</li>
<li>-f&lt;拒绝文件&gt;或–reject-file=&lt;拒绝文件&gt; 　设置保存拒绝修补相关信息的文件名称，预设的文件名称为.rej。</li>
<li>-R或–reverse 　假设修补数据是由新旧文件交换位置而产生。</li>
<li>-s或–quiet或–silent 　不显示指令执行过程，除非发生错误。</li>
<li>-t或–batch 　自动略过错误，不询问任何问题。</li>
<li>-T或–set-time 　此参数的效果和指定”-Z”参数类似，但以本地时间为主。</li>
<li>-u或–unified 　把修补数据解译成一致化的差异。</li>
<li>-v或–version 　显示版本信息。</li>
<li>-V&lt;备份方式&gt;或–version-control=&lt;备份方式&gt; 　用”-b”参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用”-z”参数变更，当使用”-V”参数指定不同备份方式时，也会产生不同字尾的备份字符串。</li>
<li>-Y&lt;备份字首字符串&gt;或–basename-prefix=–&lt;备份字首字符串&gt; 　设置文件备份时，附加在文件基本名称开头的字首字符串。</li>
<li>-z&lt;备份字尾字符串&gt;或–suffix=&lt;备份字尾字符串&gt; 　此参数的效果和指定”-B”参数类似，差别在于修补作业使用的路径与文件名若为src/linux/fs/super.c，加上”backup/“字符串后，文件super.c会备份于/src/linux/fs/backup目录里。</li>
<li>-Z或–set-utc 　把修补过的文件更改，存取时间设为UTC。</li>
<li>–backup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，才备份文件。</li>
<li>–binary 　以二进制模式读写数据，而不通过标准输出设备。</li>
<li>–help 　在线帮助。</li>
<li>–nobackup-if-mismatch 　在修补数据不完全吻合，且没有刻意指定要备份文件时，不要备份文件。</li>
<li>–verbose 　详细显示指令的执行过程。</li>
</ul>
<h3 id="实例-28"><a href="#实例-28" class="headerlink" title="实例"></a>实例</h3><p>使用patch指令将文件”testfile1”升级，其升级补丁文件为”testfile.patch”，输入如下命令：</p>
<pre><code>$ patch -p0 testfile1 testfile.patch    #使用补丁程序升级文件 </code></pre><p>使用该命令前，可以先使用指令”cat”查看”testfile1”的内容。在需要修改升级的文件与原文件之间使用指令”diff”比较可以生成补丁文件。具体操作如下所示：</p>
<pre><code>$ cat testfile1                 #查看testfile1的内容  
Hello,This is the firstfile!  
$ cat testfile2                 #查看testfile2的内容  
Hello,Thisisthesecondfile!  
$ diff testfile1 testfile2          #比较两个文件  
1c1  
&lt;Hello,Thisisthefirstfile!  
---  
&gt;Hello,Thisisthesecondfile!  
#将比较结果保存到tetsfile.patch文件  
$ diff testfile1 testfile2&gt;testfile.patch     
$ cat testfile.patch                #查看补丁包的内容  
1c1  
&lt;Hello,Thisisthefirstfile!  
---  
&gt;Hello,Thisisthesecondfile!  
#使用补丁包升级testfile1文件  
$ patch -p0 testfile1 testfile.patch      
patching file testfile1  
$cat testfile1                  #再次查看testfile1的内容  
#testfile1文件被修改为与testfile2一样的内容  
Hello,This is the secondfile!   </code></pre><p>注意：上述命令代码中，”$ diff testfile1 testfile2&gt;testfile. patch”所使用的操作符”＞”表示将该操作符左边的文件数据写入到右边所指向的文件中。在这里，即是指将两个文件比较后的结果写入到文件”testfile.patch”中。</p>
<h2 id="35-rcp"><a href="#35-rcp" class="headerlink" title="35.rcp"></a>35.rcp</h2><p>​        rcp命令用于复制远程文件或目录。</p>
<p>rcp指令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。</p>
<h3 id="语法-33"><a href="#语法-33" class="headerlink" title="语法"></a>语法</h3><pre><code>rcp [-pr][源文件或目录][目标文件或目录]</code></pre><p>或</p>
<pre><code>rcp [-pr][源文件或目录...][目标文件]</code></pre><p><strong>参数</strong>：</p>
<p>-p 　保留源文件或目录的属性，包括拥有者，所属群组，权限与时间。</p>
<p>-r 　递归处理，将指定目录下的文件与子目录一并处理。</p>
<h3 id="实例-29"><a href="#实例-29" class="headerlink" title="实例"></a>实例</h3><p>使用rcp指令复制远程文件到本地进行保存。</p>
<p>设本地主机当前账户为rootlocal，远程主机账户为root，要将远程主机（218.6.132.5）主目录下的文件”testfile”复制到本地目录”test”中，则输入如下命令：</p>
<pre><code>rcp root@218.6.132.5:./testfile testfile  #复制远程文件到本地  
rcp root@218.6.132.5:home/rootlocal/testfile testfile  
#要求当前登录账户cmd 登录到远程主机  
rcp 218.6.132.5:./testfile testfile</code></pre><p>注意：指令”rcp”执行以后不会有返回信息，仅需要在目录”test”下查看是否存在文件”testfile”。若存在，则表示远程复制操作成功，否则远程复制操作失败。</p>
<h2 id="36-rm"><a href="#36-rm" class="headerlink" title="36.rm"></a>36.rm</h2><p>​         rm命令用于删除一个文件或者目录。</p>
<h3 id="语法-34"><a href="#语法-34" class="headerlink" title="语法"></a>语法</h3><pre><code>rm [options] name...</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-i 删除前逐一询问确认。</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li>
<li>-r 将目录及以下之档案亦逐一删除。</li>
</ul>
<h3 id="实例-30"><a href="#实例-30" class="headerlink" title="实例"></a>实例</h3><p>删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，例如：</p>
<pre><code># rm  test.txt 
rm：是否删除 一般文件 &quot;test.txt&quot;? y  
# rm  homework  
rm: 无法删除目录&quot;homework&quot;: 是一个目录  
# rm  -r  homework  
rm：是否删除 目录 &quot;homework&quot;? y </code></pre><p>删除当前目录下的所有文件及目录，命令行为：</p>
<pre><code>rm  -r  * </code></pre><p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
<h2 id="37-slocate"><a href="#37-slocate" class="headerlink" title="37.slocate"></a>37.slocate</h2><p>​        slocate命令查找文件或目录。</p>
<p>slocate本身具有一个数据库，里面存放了系统中文件与目录的相关信息。</p>
<h3 id="语法-35"><a href="#语法-35" class="headerlink" title="语法"></a>语法</h3><pre><code>slocate [-u][--help][--version][-d &lt;目录&gt;][查找的文件]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-d&lt;目录&gt;或–database=&lt;目录&gt; 　指定数据库所在的目录。</li>
<li>-u 　更新slocate数据库。</li>
<li>–help 　显示帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例-31"><a href="#实例-31" class="headerlink" title="实例"></a>实例</h3><p>使用指令”slocate”显示文件名中含有关键字”fdisk”的文件路径信息，输入如下命令：</p>
<pre><code>$ slocate fdisk #显示文件名中含有fdisk关键字的文件的路径信息 </code></pre><p>执行以上命令后，指令执行的输出信息如下：</p>
<pre><code>$ slocate fdisk #显示文件名中含有fdisk 关键字的文件的路径信息  
/root/cfdisk        #搜索到的文件路径列表  
/root/fdisk  
/root/sfdisk  
/usr/include/grub/ieee1275/ofdisk.h  
/usr/share/doc/util-Linux/README.cfdisk  
/usr/share/doc/util-Linux/README.fdisk.gz  
/usr/share/doc/util-Linux/examples/sfdisk.examples.gz  </code></pre><h2 id="38-split"><a href="#38-split" class="headerlink" title="38.split"></a>38.split</h2><p>​        split命令用于将一个文件分割成数个。</p>
<p>该指令将大文件分割成较小的文件，在默认情况下将按照每1000行切割成一个小文件。</p>
<h3 id="语法-36"><a href="#语法-36" class="headerlink" title="语法"></a>语法</h3><pre><code>split [--help][--version][-&lt;行数&gt;][-b &lt;字节&gt;][-C &lt;字节&gt;][-l &lt;行数&gt;][要切割的文件][输出文件名]</code></pre><p><strong>参数说明</strong>：</p>
<ul>
<li>-&lt;行数&gt; : 指定每多少行切成一个小文件</li>
<li>-b&lt;字节&gt; : 指定每多少字节切成一个小文件</li>
<li>–help : 在线帮助</li>
<li>–version : 显示版本信息</li>
<li>-C&lt;字节&gt; : 与参数”-b”相似，但是在切 割时将尽量维持每行的完整性</li>
<li>[输出文件名] : 设置切割后文件的前置文件名， split会自动在前置文件名后再加上编号</li>
</ul>
<h3 id="实例-32"><a href="#实例-32" class="headerlink" title="实例"></a>实例</h3><p>使用指令”split”将文件”README”每6行切割成一个文件，输入如下命令：</p>
<pre><code>$ split -6 README       #将README文件每六行分割成一个文件 </code></pre><p>以上命令执行后，指令”split”会将原来的大文件”README”切割成多个以”x”开头的小文件。而在这些小文件中，每个文件都只有6行内容。</p>
<p>使用指令”ls”查看当前目录结构，如下所示：</p>
<pre><code>$ ls                                #执行ls指令  
#获得当前目录结构  
README xaa xad xag xab xae xah xac xaf xai    </code></pre><h2 id="39-tee"><a href="#39-tee" class="headerlink" title="39.tee"></a>39.tee</h2><p>​        tee命令用于读取标准输入的数据，并将其内容输出成文件。</p>
<p>tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p>
<h3 id="语法-37"><a href="#语法-37" class="headerlink" title="语法"></a>语法</h3><pre><code>tee [-ai][--help][--version][文件...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-a或–append 　附加到既有文件的后面，而非覆盖它．</li>
<li>-i或–ignore-interrupts 　忽略中断信号。</li>
<li>–help 　在线帮助。</li>
<li>–version 　显示版本信息。</li>
</ul>
<h3 id="实例-33"><a href="#实例-33" class="headerlink" title="实例"></a>实例</h3><p>使用指令”tee”将用户输入的数据同时保存到文件”file1”和”file2”中，输入如下命令：</p>
<pre><code>$ tee file1 file2                   #在两个文件中复制内容 </code></pre><p>以上命令执行后，将提示用户输入需要保存到文件的数据，如下所示：</p>
<pre><code>My Linux                        #提示用户输入数据  
My Linux                        #输出数据，进行输出反馈  </code></pre><p>此时，可以分别打开文件”file1”和”file2”，查看其内容是否均是”My Linux”即可判断指令”tee”是否执行成功。</p>
<h2 id="40-tmpwatch"><a href="#40-tmpwatch" class="headerlink" title="40.tmpwatch"></a>40.tmpwatch</h2><p>​        tmpwatch命令用于删除暂存文件。</p>
<p>执行tmpwatch指令可删除不必要的暂存文件，您可以设置文件超期时间，单位以小时计算。</p>
<h3 id="语法-38"><a href="#语法-38" class="headerlink" title="语法"></a>语法</h3><pre><code>tmpwatch [-afqv][--test][超期时间][目录...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-a或–all 　删除任何类型的文件。</li>
<li>-f或–force 　强制删除文件或目录，其效果类似rm指令的”-f”参数。</li>
<li>-q或–quiet 　不显示指令执行过程。</li>
<li>-v或–verbose 　详细显示指令执行过程。</li>
<li>-test 　仅作测试，并不真的删除文件或目录。</li>
</ul>
<h3 id="实例-34"><a href="#实例-34" class="headerlink" title="实例"></a>实例</h3><p>使用指令”tmpwatch”删除目录”/tmp”中超过一天未使用的文件，输入如下命令：</p>
<pre><code>$ tmpwatch 24 /tmp/ #删除/tmp目录中超过一天未使用的文件</code></pre><p>以上命令执行后，其执行结果如下所示：</p>
<pre><code>removing directctmp/orbit-tom if not empty </code></pre><p>注意：该指令需要root权限，因此在使用tmpwatch命令前应该使用su命令切换用户。切换管理权限操作如下所示：</p>
<pre><code>$ su                                #切换到root用户  
口令：**********                   #输入用户密码  </code></pre><h2 id="41-touch"><a href="#41-touch" class="headerlink" title="41.touch"></a>41.touch</h2><p>​        touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p>ls -l 可以显示档案的时间记录。</p>
<h3 id="语法-39"><a href="#语法-39" class="headerlink" title="语法"></a>语法</h3><pre><code>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</code></pre><ul>
<li><strong>参数说明</strong>：</li>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录。</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 –file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<h3 id="实例-35"><a href="#实例-35" class="headerlink" title="实例"></a>实例</h3><p>使用指令”touch”修改文件”testfile”的时间属性为当前系统时间，输入如下命令：</p>
<pre><code>$ touch testfile                #修改文件的时间属性 </code></pre><p>首先，使用ls命令查看testfile文件的属性，如下所示：</p>
<pre><code>$ ls -l testfile                #查看文件的时间属性  
#原来文件的修改时间为16:09  
-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile  </code></pre><p>执行指令”touch”修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p>
<pre><code>$ touch testfile                #修改文件时间属性为当前系统时间  
$ ls -l testfile                #查看文件的时间属性  
#修改后文件的时间属性为当前系统时间  
-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile  </code></pre><p>使用指令”touch”时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件”file”，输入如下命令：</p>
<pre><code>$ touch file            #创建一个名为“file”的新的空白文件 </code></pre><h2 id="42-umask"><a href="#42-umask" class="headerlink" title="42.umask"></a>42.umask</h2><p>​        umask命令指定在建立文件时预设的权限掩码。</p>
<p>umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。</p>
<h3 id="语法-40"><a href="#语法-40" class="headerlink" title="语法"></a>语法</h3><pre><code>umask [-S][权限掩码]</code></pre><p><strong>参数说明</strong>：</p>
<p>-S 　以文字的方式来表示权限掩码。</p>
<h3 id="实例-36"><a href="#实例-36" class="headerlink" title="实例"></a>实例</h3><p>使用指令”umask”查看当前权限掩码，则输入下面的命令：</p>
<pre><code>$ umask                         #获取当前权限掩码 </code></pre><p>执行上面的指令后，输出信息如下：</p>
<pre><code>0022</code></pre><p>接下来，使用指令”mkdir”创建一个目录，并使用指令”ls”获取该目录的详细信息，输入命令如下：</p>
<pre><code>$ mkdir test1                       #创建目录  
$ ls –d –l test1/                   #显示目录的详细信息  </code></pre><p>执行上面的命令后，将显示新创建目录的详细信息，如下所示：</p>
<pre><code>drwxr-xr-x 2 rootlocal rootlocal 4096 2011-9-19 21:46 test1/ </code></pre><p>注意：在上面的输出信息中，”drwxr-xr-x”=”777-022=755”。</p>
<h2 id="43-which"><a href="#43-which" class="headerlink" title="43.which"></a>43.which</h2><p>​        which命令用于查找文件。</p>
<p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p>
<h3 id="语法-41"><a href="#语法-41" class="headerlink" title="语法"></a>语法</h3><pre><code>which [文件...]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</li>
<li>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。</li>
<li>-w 　指定输出时栏位的宽度。</li>
<li>-V 　显示版本信息。</li>
</ul>
<h3 id="实例-37"><a href="#实例-37" class="headerlink" title="实例"></a>实例</h3><p>使用指令”which”查看指令”bash”的绝对路径，输入如下命令：</p>
<pre><code>$ which bash</code></pre><p>上面的指令执行后，输出信息如下所示：</p>
<pre><code>/bin/bash                   #bash可执行程序的绝对路径 </code></pre><h2 id="44-cp"><a href="#44-cp" class="headerlink" title="44.cp"></a>44.cp</h2><p>​        cp命令主要用于复制文件或目录。</p>
<h3 id="语法-42"><a href="#语法-42" class="headerlink" title="语法"></a>语法</h3><pre><code>cp [options] source dest</code></pre><p>或</p>
<pre><code>cp [options] source... directory</code></pre><p><strong>参数说明</strong>：</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
<li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li>
<li>-f：覆盖已经存在的目标文件而不给出提示。</li>
<li>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li>
<li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
<li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li>
<li>-l：不复制文件，只是生成链接文件。</li>
</ul>
<h3 id="实例-38"><a href="#实例-38" class="headerlink" title="实例"></a>实例</h3><p>使用指令”cp”将当前目录”test/“下的所有文件复制到新目录”newtest”下，输入如下命令：</p>
<pre><code>$ cp –r test/ newtest          </code></pre><p>注意：用户使用该指令复制目录时，必须使用参数”-r”或者”-R”。</p>
<h2 id="45-whereis"><a href="#45-whereis" class="headerlink" title="45.whereis"></a>45.whereis</h2><p>​        whereis命令用于查找文件。</p>
<p>该指令会在特定目录中查找符合条件的文件。这些文件应属于原始代码、二进制文件，或是帮助文件。</p>
<p>该指令只能用于查找二进制文件、源代码文件和man手册页，一般文件的定位需使用locate命令。</p>
<h3 id="语法-43"><a href="#语法-43" class="headerlink" title="语法"></a>语法</h3><pre><code>whereis [-bfmsu][-B &lt;目录&gt;...][-M &lt;目录&gt;...][-S &lt;目录&gt;...][文件...]</code></pre><p><strong>参数</strong>：</p>
<p>-b 　只查找二进制文件。</p>
<p>-B&lt;目录&gt; 　只在设置的目录下查找二进制文件。</p>
<p>-f 　不显示文件名前的路径名称。</p>
<p>-m 　只查找说明文件。</p>
<p>-M&lt;目录&gt; 　只在设置的目录下查找说明文件。</p>
<p>-s 　只查找原始代码文件。</p>
<p>-S&lt;目录&gt; 　只在设置的目录下查找原始代码文件。</p>
<p>-u 　查找不包含指定类型的文件。</p>
<h3 id="实例-39"><a href="#实例-39" class="headerlink" title="实例"></a>实例</h3><p>使用指令”whereis”查看指令”bash”的位置，输入如下命令：</p>
<pre><code>$ whereis bash </code></pre><p>上面的指令执行后，输出信息如下所示：</p>
<pre><code>bash:/bin/bash/etc/bash.bashrc/usr/share/man/man1/bash.1.gz </code></pre><p>注意：以上输出信息从左至右分别为查询的程序名、bash路径、bash的man 手册页路径。</p>
<p>如果用户需要单独查询二进制文件或帮助文件，可使用如下命令：</p>
<pre><code>$ whereis -b bash 
$ whereis -m bash </code></pre><p>输出信息如下：</p>
<pre><code>$ whereis -b bash               #显示bash 命令的二进制程序  
bash: /bin/bash /etc/bash.bashrc /usr/share/bash    # bash命令的二进制程序的地址  
$ whereis -m bash               #显示bash 命令的帮助文件  
bash: /usr/share/man/man1/bash.1.gz  #bash命令的帮助文件地址  </code></pre><h2 id="46-mcopy"><a href="#46-mcopy" class="headerlink" title="46.mcopy"></a>46.mcopy</h2><p>​        mcopy命令用来复制 MSDOS 格式文件到 Linux 中，或是由 Linux 中复制 MSDOS 文件到磁片上。</p>
<p>mcopy 可复制单一的文件到所指定的文件名称，或是复制数个文件到所指定的目录之中。来源与目的文件可为 MSDOS 或是 Linux 文件。</p>
<p>mcopy指令是一种mtools工具指令，可以在DOS系统中复制文件或者在DOS与Linux操作系统之间进行文件复制。</p>
<h3 id="语法-44"><a href="#语法-44" class="headerlink" title="语法"></a>语法</h3><pre><code>mcopy [-bnmpQt/][源文件][目标文件或目录]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>b 批处理模式。这是为大量的文件复制进行最佳化的选项,但是当在复制文件过程中产生 crash 时，会有安全性的问题产生。/ 递回的复制。包含目录所含文件与其下所有子目录中的文件。</li>
<li>-n 覆盖其他文件时，不需要进行确认而直接覆盖</li>
<li>m 将源文件修改时间设置为目标文件的修改时间。</li>
<li>p 将源文件的属性设置为目标文件的属性。</li>
<li>Q 当复制多个文件产生错误时，尽快结束程序。</li>
<li>t 转换为文本文件。</li>
<li>o 在覆盖 MSDOS 文件时不会出现警示讯息。</li>
</ul>
<h3 id="实例-40"><a href="#实例-40" class="headerlink" title="实例"></a>实例</h3><p>将 A 盘根目录中的 autoexec.bat 复制到目前工作目录之下：</p>
<pre><code>mcopy a:autoexec.bat .</code></pre><p>当复制的内容包括子目录和文件时，必须使用参数”-/“递归操作，因此该命令为：</p>
<pre><code>mcopy -/ A:\* </code></pre><p>执行该命令前先使用mdir 命令查看原来的目录结构，执行mcopy 之后可使用ls 命令查看复制之后Linux系统中的文件结构，结果如下：</p>
<pre><code>cmd@cmd-desktop:~$ mdir -/ a:\* #查看A 盘中的文件  
Volume in drive A has no label #加载信息  
Volume Serial Number is 13D2~055C  
Directory for A:/ #以下为目录信息  
#文件名目录大小 修改时间  
./TEST &lt;DIR&gt; 2009-09-23 16:59  
AUTORUN.INF 265 2009-09-23 16:53  
AUTORUN.BAT 43 2009-09-23 16:56  
3 files 308 bytes #统计总大小  
724 325 bytes free #剩余空间  
cmd@cmd-desktop:~$ mcopy -/ A:\* #将A盘上的所有文件复制到当前工作目录  
cmd@cmd-desktop:~$ls  
TEST AUTORUN.INF AUTORUN.BAT #A盘中的内容复制到Linux文件系统结构中 </code></pre><p>47.mshowfat</p>
<p>​        mshowfat命令用于显示MS-DOS文件在FAT中的记录。</p>
<p>mshowfat为mtools工具指令，可显示MS-DOS文件在FAT中的记录编号。</p>
<h3 id="语法-45"><a href="#语法-45" class="headerlink" title="语法"></a>语法</h3><pre><code>mshowfat [文件...]</code></pre><p><strong>参数说明：</strong></p>
<p>[文件…]： 执行操作的文件相对路径或者绝对路径</p>
<h3 id="实例-41"><a href="#实例-41" class="headerlink" title="实例"></a>实例</h3><p>使用指令mshowfat查看文件”autorun.bat”的FAT信息，输入如下命令：</p>
<pre><code>$ mshowfat autorun.bat </code></pre><p>以上命令执行后，文件”autorun.bat”的FAT相关信息将会被显示出来。</p>
<p>注意：执行操作的文件必须是DOS文件系统下的文件。</p>
<h2 id="48-rhmask"><a href="#48-rhmask" class="headerlink" title="48.rhmask"></a>48.rhmask</h2><p>​        rhmask命令用于对文件进行加密和解密操作。</p>
<p>执行rhmask指令可制作加密过的文件，方便用户在公开的网络上传输该文件，而不至于被任意盗用。</p>
<h3 id="语法-46"><a href="#语法-46" class="headerlink" title="语法"></a>语法</h3><pre><code>rhmask [加密文件][输出文件] 或 rhmask [-d][加密文件][源文件][输出文件]</code></pre><p><strong>参数</strong>：</p>
<ul>
<li>-d 　产生加密过的文件。</li>
</ul>
<h3 id="实例-42"><a href="#实例-42" class="headerlink" title="实例"></a>实例</h3><p>使用指令”rhmask”将加密文件”code.txt”进行加密后，另存为输出文件”demo.txt”，输入如下命令：</p>
<pre><code>$ rhmask code.txt demo.txt</code></pre><p>以上命令执行后，文件”code.txt”将被加密后，另存为已经加密的文件”demo.txt”。</p>
<p>注意：该指令有两种语法，用户可以有选择性地进行使用即可。</p>
<h2 id="49-scp"><a href="#49-scp" class="headerlink" title="49.scp"></a>49.scp</h2><pre><code>     scp命令用于Linux之间复制文件和目录。</code></pre><p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p>
<h3 id="语法-47"><a href="#语法-47" class="headerlink" title="语法"></a>语法</h3><pre><code>scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]
[-l limit] [-o ssh_option] [-P port] [-S program]
[[user@]host1:]file1 [...] [[user@]host2:]file2</code></pre><p>简易写法:</p>
<pre><code>scp [可选参数] file_source file_target </code></pre><p><strong>参数说明：</strong></p>
<ul>
<li>-1： 强制scp命令使用协议ssh1</li>
<li>-2： 强制scp命令使用协议ssh2</li>
<li>-4： 强制scp命令只使用IPv4寻址</li>
<li>-6： 强制scp命令只使用IPv6寻址</li>
<li>-B： 使用批处理模式（传输过程中不询问传输口令或短语）</li>
<li>-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
<li>-p：保留原文件的修改时间，访问时间和访问权限。</li>
<li>-q： 不显示传输进度条。</li>
<li>-r： 递归复制整个目录。</li>
<li>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
<li>-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
<li>-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
<li>-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
<li>-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。</li>
<li>-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，</li>
<li>-P port：注意是大写的P, port是指定数据传输用到的端口号</li>
<li>-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
<h3 id="实例-43"><a href="#实例-43" class="headerlink" title="实例"></a>实例</h3><h4 id="1、从本地复制到远程"><a href="#1、从本地复制到远程" class="headerlink" title="1、从本地复制到远程"></a>1、从本地复制到远程</h4><p>命令格式：</p>
<pre><code>scp local_file remote_username@remote_ip:remote_folder 
或者 
scp local_file remote_username@remote_ip:remote_file 
或者 
scp local_file remote_ip:remote_folder 
或者 
scp local_file remote_ip:remote_file </code></pre><ul>
<li>第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名；</li>
<li>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名；</li>
</ul>
<p>应用实例：</p>
<pre><code>scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music 
scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3 
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music 
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 </code></pre><p>复制目录命令格式：</p>
<pre><code>scp -r local_folder remote_username@remote_ip:remote_folder 
或者 
scp -r local_folder remote_ip:remote_folder </code></pre><ul>
<li>第1个指定了用户名，命令执行后需要再输入密码；</li>
<li>第2个没有指定用户名，命令执行后需要输入用户名和密码；</li>
</ul>
<p>应用实例：</p>
<pre><code>scp -r /home/space/music/ root@www.runoob.com:/home/root/others/ 
scp -r /home/space/music/ www.runoob.com:/home/root/others/ </code></pre><p>上面命令将本地 music 目录复制到远程 others 目录下。</p>
<h4 id="2、从远程复制到本地"><a href="#2、从远程复制到本地" class="headerlink" title="2、从远程复制到本地"></a>2、从远程复制到本地</h4><p>从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例</p>
<p>应用实例：</p>
<pre><code>scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 
scp -r www.runoob.com:/home/root/others/ /home/space/music/</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下：</p>
<pre><code>#scp 命令使用端口号 4588
scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator</code></pre><p>2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。</p>
<h2 id="50-awk"><a href="#50-awk" class="headerlink" title="50.awk"></a>50.awk</h2><p>​        AWK是一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<p>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p>
<h3 id="语法-48"><a href="#语法-48" class="headerlink" title="语法"></a>语法</h3><pre><code>awk [选项参数] &#39;script&#39; var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)</code></pre><p><strong>选项参数说明：</strong></p>
<ul>
<li><p>-F fs or –field-separator fs</p>
<p>  指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</p>
</li>
<li><p>-v var=value or –asign var=value</p>
<p>  赋值一个用户定义变量。</p>
</li>
<li><p>-f scripfile or –file scriptfile</p>
<p>  从脚本文件中读取awk命令。</p>
</li>
<li><p>-mf nnn and -mr nnn</p>
<p>  对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</p>
</li>
<li><p>-W compact or –compat, -W traditional or –traditional</p>
<p>  在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</p>
</li>
<li><p>-W copyleft or –copyleft, -W copyright or –copyright</p>
<p>  打印简短的版权信息。</p>
</li>
<li><p>-W help or –help, -W usage or –usage</p>
<p>  打印全部awk选项和每个选项的简短说明。</p>
</li>
<li><p>-W lint or –lint</p>
<p>  打印不能向传统unix平台移植的结构的警告。</p>
</li>
<li><p>-W lint-old or –lint-old</p>
<p>  打印关于不能向传统unix平台移植的结构的警告。</p>
</li>
<li><p>-W posix</p>
<p>  打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替^和^=；fflush无效。</p>
</li>
<li><p>-W re-interval or –re-inerval</p>
<p>  允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</p>
</li>
<li><p>-W source program-text or –source program-text</p>
<p>  使用program-text作为源代码，可与-f命令混用。</p>
</li>
<li><p>-W version or –version</p>
<p>  打印bug报告信息的版本。</p>
</li>
</ul>
<hr>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>log.txt文本内容如下：</p>
<pre><code>2 this is a test
3 Are you like awk
This&#39;s a test
10 There are orange,apple,mongo</code></pre><p>用法一：</p>
<pre><code>awk &#39;{[pattern] action}&#39; {filenames}   # 行匹配语句 awk &#39;&#39; 只能用单引号</code></pre><p>实例：</p>
<pre><code># 每行按空格或TAB分割，输出文本中的1、4项
 $ awk &#39;{print $1,$4}&#39; log.txt
 ---------------------------------------------
 2 a
 3 like
 This&#39;s
 10 orange,apple,mongo
 # 格式化输出
 $ awk &#39;{printf &quot;%-8s %-10s\n&quot;,$1,$4}&#39; log.txt
 ---------------------------------------------
 2        a
 3        like
 This&#39;s
 10       orange,apple,mongo
</code></pre><p>用法二：</p>
<pre><code>awk -F  #-F相当于内置变量FS, 指定分割字符</code></pre><p>实例：</p>
<pre><code># 使用&quot;,&quot;分割
 $  awk -F, &#39;{print $1,$2}&#39;   log.txt
 ---------------------------------------------
 2 this is a test
 3 Are you like awk
 This&#39;s a test
 10 There are orange apple
 # 或者使用内建变量
 $ awk &#39;BEGIN{FS=&quot;,&quot;} {print $1,$2}&#39;     log.txt
 ---------------------------------------------
 2 this is a test
 3 Are you like awk
 This&#39;s a test
 10 There are orange apple
 # 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割
 $ awk -F &#39;[ ,]&#39;  &#39;{print $1,$2,$5}&#39;   log.txt
 ---------------------------------------------
 2 this test
 3 Are awk
 This&#39;s a
 10 There apple</code></pre><p>用法三：</p>
<pre><code>awk -v  # 设置变量</code></pre><p>实例：</p>
<pre><code> $ awk -va=1 &#39;{print $1,$1+a}&#39; log.txt
 ---------------------------------------------
 2 3
 3 4
 This&#39;s 1
 10 11
 $ awk -va=1 -vb=s &#39;{print $1,$1+a,$1b}&#39; log.txt
 ---------------------------------------------
 2 3 2s
 3 4 3s
 This&#39;s 1 This&#39;ss
 10 11 10s</code></pre><p>用法四：</p>
<pre><code>awk -f {awk脚本} {文件名}</code></pre><p>实例：</p>
<pre><code> $ awk -f cal.awk log.txt</code></pre><hr>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">= += -= <em>= /= %= ^= *</em>=</td>
<td align="left">赋值</td>
</tr>
<tr>
<td align="left">?:</td>
<td align="left">C条件表达式</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑或</td>
</tr>
<tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑与</td>
</tr>
<tr>
<td align="left">~ 和 !~</td>
<td align="left">匹配正则表达式和不匹配正则表达式</td>
</tr>
<tr>
<td align="left">&lt; &lt;= &gt; &gt;= != ==</td>
<td align="left">关系运算符</td>
</tr>
<tr>
<td align="left">空格</td>
<td align="left">连接</td>
</tr>
<tr>
<td align="left">+ -</td>
<td align="left">加，减</td>
</tr>
<tr>
<td align="left">* / %</td>
<td align="left">乘，除与求余</td>
</tr>
<tr>
<td align="left">+ - !</td>
<td align="left">一元加，减和逻辑非</td>
</tr>
<tr>
<td align="left">^ ***</td>
<td align="left">求幂</td>
</tr>
<tr>
<td align="left">++ –</td>
<td align="left">增加或减少，作为前缀或后缀</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">字段引用</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">数组成员</td>
</tr>
</tbody></table>
<p>过滤第一列大于2的行</p>
<pre><code>$ awk &#39;$1&gt;2&#39; log.txt    #命令
#输出
3 Are you like awk
This&#39;s a test
10 There are orange,apple,mongo</code></pre><p>过滤第一列等于2的行</p>
<pre><code>$ awk &#39;$1==2 {print $1,$3}&#39; log.txt    #命令
#输出
2 is</code></pre><p>过滤第一列大于2并且第二列等于’Are’的行</p>
<pre><code>$ awk &#39;$1&gt;2 &amp;&amp; $2==&quot;Are&quot; {print $1,$2,$3}&#39; log.txt    #命令
#输出
3 Are you</code></pre><hr>
<h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$n</td>
<td align="left">当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr>
<td align="left">$0</td>
<td align="left">完整的输入记录</td>
</tr>
<tr>
<td align="left">ARGC</td>
<td align="left">命令行参数的数目</td>
</tr>
<tr>
<td align="left">ARGIND</td>
<td align="left">命令行中当前文件的位置(从0开始算)</td>
</tr>
<tr>
<td align="left">ARGV</td>
<td align="left">包含命令行参数的数组</td>
</tr>
<tr>
<td align="left">CONVFMT</td>
<td align="left">数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>
</tr>
<tr>
<td align="left">ERRNO</td>
<td align="left">最后一个系统错误的描述</td>
</tr>
<tr>
<td align="left">FIELDWIDTHS</td>
<td align="left">字段宽度列表(用空格键分隔)</td>
</tr>
<tr>
<td align="left">FILENAME</td>
<td align="left">当前文件名</td>
</tr>
<tr>
<td align="left">FNR</td>
<td align="left">各文件分别计数的行号</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">字段分隔符(默认是任何空格)</td>
</tr>
<tr>
<td align="left">IGNORECASE</td>
<td align="left">如果为真，则进行忽略大小写的匹配</td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">一条记录的字段的数目</td>
</tr>
<tr>
<td align="left">NR</td>
<td align="left">已经读出的记录数，就是行号，从1开始</td>
</tr>
<tr>
<td align="left">OFMT</td>
<td align="left">数字的输出格式(默认值是%.6g)</td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td>
</tr>
<tr>
<td align="left">ORS</td>
<td align="left">输出记录分隔符(默认值是一个换行符)</td>
</tr>
<tr>
<td align="left">RLENGTH</td>
<td align="left">由match函数所匹配的字符串的长度</td>
</tr>
<tr>
<td align="left">RS</td>
<td align="left">记录分隔符(默认是一个换行符)</td>
</tr>
<tr>
<td align="left">RSTART</td>
<td align="left">由match函数所匹配的字符串的第一个位置</td>
</tr>
<tr>
<td align="left">SUBSEP</td>
<td align="left">数组下标分隔符(默认值是/034)</td>
</tr>
</tbody></table>
<pre><code>$ awk &#39;BEGIN{printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\n&quot;,&quot;FILENAME&quot;,&quot;ARGC&quot;,&quot;FNR&quot;,&quot;FS&quot;,&quot;NF&quot;,&quot;NR&quot;,&quot;OFS&quot;,&quot;ORS&quot;,&quot;RS&quot;;printf &quot;---------------------------------------------\n&quot;} {printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\n&quot;,FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}&#39;  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1         5    1
log.txt    2    2         5    2
log.txt    2    3         3    3
log.txt    2    4         4    4
$ awk -F\&#39; &#39;BEGIN{printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\n&quot;,&quot;FILENAME&quot;,&quot;ARGC&quot;,&quot;FNR&quot;,&quot;FS&quot;,&quot;NF&quot;,&quot;NR&quot;,&quot;OFS&quot;,&quot;ORS&quot;,&quot;RS&quot;;printf &quot;---------------------------------------------\n&quot;} {printf &quot;%4s %4s %4s %4s %4s %4s %4s %4s %4s\n&quot;,FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}&#39;  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1    &#39;    1    1
log.txt    2    2    &#39;    1    2
log.txt    2    3    &#39;    2    3
log.txt    2    4    &#39;    1    4
# 输出顺序号 NR, 匹配文本行号
$ awk &#39;{print NR,FNR,$1,$2,$3}&#39; log.txt
---------------------------------------------
1 1 2 this is
2 2 3 Are you
3 3 This&#39;s a test
4 4 10 There are
# 指定输出分割符
$  awk &#39;{print $1,$2,$5}&#39; OFS=&quot; $ &quot;  log.txt
---------------------------------------------
2 $ this $ test
3 $ Are $ awk
This&#39;s $ a $
10 $ There $</code></pre><hr>
<h3 id="使用正则，字符串匹配"><a href="#使用正则，字符串匹配" class="headerlink" title="使用正则，字符串匹配"></a>使用正则，字符串匹配</h3><pre><code># 输出第二列包含 &quot;th&quot;，并打印第二列与第四列
$ awk &#39;$2 ~ /th/ {print $2,$4}&#39; log.txt
---------------------------------------------
this a</code></pre><p><strong>~ 表示模式开始。// 中是模式。</strong></p>
<pre><code># 输出包含&quot;re&quot; 的行
$ awk &#39;/re/ &#39; log.txt
---------------------------------------------
3 Are you like awk
10 There are orange,apple,mongo</code></pre><hr>
<h3 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h3><pre><code>$ awk &#39;BEGIN{IGNORECASE=1} /this/&#39; log.txt
---------------------------------------------
2 this is a test
This&#39;s a test</code></pre><hr>
<h3 id="模式取反"><a href="#模式取反" class="headerlink" title="模式取反"></a>模式取反</h3><pre><code>$ awk &#39;$2 !~ /th/ {print $2,$4}&#39; log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo
$ awk &#39;!/th/ {print $2,$4}&#39; log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo</code></pre><hr>
<h3 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h3><p>关于awk脚本，我们需要注意两个关键词BEGIN和END。</p>
<ul>
<li>BEGIN{ 这里面放的是执行前的语句 }</li>
<li>END {这里面放的是处理完所有的行后要执行的语句 }</li>
<li>{这里面放的是处理每一行时要执行的语句}</li>
</ul>
<p>假设有这么一个文件（学生成绩表）：</p>
<pre><code>$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62</code></pre><p>我们的awk脚本如下：</p>
<pre><code>$ cat cal.awk
#!/bin/awk -f
#运行前
BEGIN {
    math = 0
    english = 0
    computer = 0

    printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;
    printf &quot;---------------------------------------------\n&quot;
}
#运行中
{
    math+=$3
    english+=$4
    computer+=$5
    printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5
}
#运行后
END {
    printf &quot;---------------------------------------------\n&quot;
    printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer
    printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math/NR, english/NR, computer/NR
}</code></pre><p>我们来看一下执行结果：</p>
<pre><code>$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00</code></pre><hr>
<h3 id="另外一些实例"><a href="#另外一些实例" class="headerlink" title="另外一些实例"></a>另外一些实例</h3><p>AWK的hello world程序为：</p>
<pre><code>BEGIN { print &quot;Hello, world!&quot; }</code></pre><p>计算文件大小</p>
<pre><code>$ ls -l *.txt | awk &#39;{sum+=$6} END {print sum}&#39;
--------------------------------------------------
666581</code></pre><p>从文件中找出长度大于80的行</p>
<pre><code>awk &#39;length&gt;80&#39; log.txt</code></pre><p>打印九九乘法表</p>
<pre><code>seq 9 | sed &#39;H;g&#39; | awk -v RS=&#39;&#39; &#39;{for(i=1;i&lt;=NF;i++)printf(&quot;%dx%d=%d%s&quot;, i, NR, i*NR, i==NR?&quot;\n&quot;:&quot;\t&quot;)}&#39;</code></pre><blockquote>
<p>更多内容：</p>
<ul>
<li><a href="https://www.runoob.com/w3cnote/awk-work-principle.html" target="_blank" rel="noopener">AWK 工作原理</a></li>
<li><a href="https://www.runoob.com/w3cnote/awk-arrays.html" target="_blank" rel="noopener">AWK 数组</a></li>
<li><a href="https://www.runoob.com/w3cnote/awk-if-loop.html" target="_blank" rel="noopener">AWK 条件语句与循环</a></li>
<li><a href="https://www.runoob.com/w3cnote/awk-user-defined-functions.html" target="_blank" rel="noopener">AWK 用户自定义函数</a></li>
<li><a href="https://www.runoob.com/w3cnote/awk-built-in-functions.html" target="_blank" rel="noopener">AWK 内置函数</a></li>
<li><a href="https://www.runoob.com/w3cnote/8-awesome-awk-built-in-variables.html" target="_blank" rel="noopener">8 个有力的 Awk 内建变量</a></li>
<li><a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">AWK 官方手册</a></li>
</ul>
</blockquote>
<h2 id="51-read"><a href="#51-read" class="headerlink" title="51.read"></a>51.read</h2><p>​        read命令用于从标准输入读取数值。</p>
<p>read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。</p>
<h3 id="语法-49"><a href="#语法-49" class="headerlink" title="语法"></a>语法</h3><pre><code>read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]</code></pre><p><strong>参数说明:</strong></p>
<ul>
<li>-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</li>
<li>-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。</li>
<li>-p 后面跟提示信息，即在输入前打印提示信息。</li>
<li>-e 在输入的时候可以使用命令补全功能。</li>
<li>-n 后跟一个数字，定义输入文本的长度，很实用。</li>
<li>-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。</li>
<li>-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</li>
<li>-t 后面跟秒数，定义输入字符的等待时间。</li>
<li>-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</li>
</ul>
<h3 id="实例-44"><a href="#实例-44" class="headerlink" title="实例"></a>实例</h3><p><strong>1、简单读取</strong></p>
<pre><code>#!/bin/bash

#这里默认会换行  
echo &quot;输入网站名: &quot;  
#读取从键盘的输入  
read website  
echo &quot;你输入的网站名是 $website&quot;  
exit 0  #退出</code></pre><p>测试结果为：</p>
<pre><code>输入网站名: 
www.runoob.com
你输入的网站名是 www.runoob.com</code></pre><p><strong>2、-p 参数，允许在 read 命令行中直接指定一个提示。</strong></p>
<pre><code>#!/bin/bash

read -p &quot;输入网站名:&quot; website
echo &quot;你输入的网站名是 $website&quot; 
exit 0</code></pre><p>测试结果为：</p>
<pre><code>输入网站名:www.runoob.com
你输入的网站名是 www.runoob.com</code></pre><p><strong>3、-t 参数指定 read 命令等待输入的秒数，当计时满时，read命令返回一个非零退出状态。</strong></p>
<pre><code>#!/bin/bash

if read -t 5 -p &quot;输入网站名:&quot; website
then
    echo &quot;你输入的网站名是 $website&quot;
else
    echo &quot;\n抱歉，你输入超时了。&quot;
fi
exit 0</code></pre><p>执行程序不输入，等待 5 秒后：</p>
<pre><code>输入网站名:
抱歉，你输入超时了</code></pre><p>4、除了输入时间计时，还可以使用 <strong>-n</strong> 参数设置 <strong>read</strong> 命令计数输入的字符。当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量。</p>
<pre><code>#!/bin/bash

read -n1 -p &quot;Do you want to continue [Y/N]?&quot; answer
case $answer in
Y | y)
      echo &quot;fine ,continue&quot;;;
N | n)
      echo &quot;ok,good bye&quot;;;
*)
     echo &quot;error choice&quot;;;

esac
exit 0</code></pre><p>该例子使用了-n 选项，后接数值 1，指示 read 命令只要接受到一个字符就退出。只要按下一个字符进行回答，read 命令立即接受输入并将其传给变量，无需按回车键。</p>
<p>只接收 2 个输入就退出：</p>
<pre><code>#!/bin/bash

read -n2 -p &quot;请随便输入两个字符: &quot; any
echo &quot;\n您输入的两个字符是:$any&quot;
exit 0</code></pre><p>执行程序输入两个字符：</p>
<pre><code>请随便输入两个字符: 12
您输入的两个字符是:12</code></pre><p>5、<strong>-s</strong> 选项能够使 <strong>read</strong> 命令中输入的数据不显示在命令终端上（实际上，数据是显示的，只是 <strong>read</strong> 命令将文本颜色设置成与背景相同的颜色）。输入密码常用这个选项。</p>
<pre><code>#!/bin/bash

read  -s  -p &quot;请输入您的密码:&quot; pass
echo &quot;\n您输入的密码是 $pass&quot;
exit 0</code></pre><p>执行程序输入密码后是不显示的：</p>
<pre><code>请输入您的密码:
您输入的密码是 runoob</code></pre><p><strong>6.读取文件</strong></p>
<p>每次调用 read 命令都会读取文件中的 “一行” 文本。当文件没有可读的行时，read 命令将以非零状态退出。</p>
<p>通过什么样的方法将文件中的数据传给 read 呢？使用 cat 命令并通过管道将结果直接传送给包含 read 命令的 while 命令。</p>
<p>测试文件 test.txt 内容如下：</p>
<pre><code>123
456
runoob</code></pre><p>测试代码：</p>
<pre><code>#!/bin/bash

count=1    # 赋值语句，不加空格
cat test.txt | while read line      # cat 命令的输出作为read命令的输入,read读到&gt;的值放在line中
do
   echo &quot;Line $count:$line&quot;
   count=$[ $count + 1 ]          # 注意中括号中的空格。
done
echo &quot;finish&quot;
exit 0</code></pre><p>执行结果为：</p>
<pre><code>Line 1:123
Line 2:456
Line 3:runoob
finish</code></pre><p>使用 <strong>-e</strong> 参数，以下实例输入字符 <strong>a</strong> 后按下 <strong>Tab</strong> 键就会输出相关的文件名(该目录存在的)：</p>
<pre><code>$ read -e -p &quot;输入文件名:&quot; str 
输入文件名:a
a.out    a.py     a.pyc    abc.txt  
输入文件名:a</code></pre><h2 id="52-updatedb"><a href="#52-updatedb" class="headerlink" title="52.updatedb"></a>52.updatedb</h2><p>​        updatedb 命令用来创建或更新 slocate/locate 命令所必需的数据库文件。</p>
<p>updatedb 命令的执行过程较长，因为在执行时它会遍历整个系统的目录树，并将所有的文件信息写入 slocate/locate 数据库文件中。</p>
<p><strong>注意：</strong>slocate 本身具有一个数据库，里面存放了系统中文件与目录的相关信息。</p>
<h3 id="语法-50"><a href="#语法-50" class="headerlink" title="语法"></a>语法</h3><pre><code>updatedb(选项)</code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li><strong>-o&lt;文件&gt;</strong>：忽略默认的数据库文件，使用指定的slocate数据库文件；</li>
<li><strong>-U&lt;目录&gt;</strong>：更新指定目录的slocate数据库；</li>
<li><strong>-v</strong>：显示执行的详细过程。</li>
</ul>
<p>以下实例检测一个未存在的文件 runoob.txt：</p>
<pre><code># locate runoob.txt   # 检索 runoob.txt，没有任何输出，表示没有该文件
# touch ./runoob.txt  # 添加文件 runoob.txt
# locate runoob.txt   # 再次检索 runoob.txt，依然没有该文件
# updatedb            # 更新 locate.db 数据库
# locate runoob.txt   # 再次数据库检索 runoob.txt，找到该文件
/root/runoob/runoob.txt</code></pre><p>使用 <strong>-U</strong> 选项可以指定要更新 slocate 数据库的目录。</p>
<pre><code>updatedb -U /root/runoob/</code></pre><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul>
<li><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-command-manual.html</a></li>
</ul>
<p><em>如有侵权，联系 <a href="mailto:2025685938@qq.com" target="_blank" rel="noopener">2025685938@qq.com</a> 删除</em></p>

            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://LHL001.github.io" class="b-link-green">yoyo</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/08/18/linux/ming-ling/1.linux-ming-ling-wen-jian-guan-li/" class="b-link-green">1.Linux命令（文件管理）</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC80NjA0MC8yMjU1MQ==">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/08/18/linux/ming-ling/2.linux-ming-ling-wen-dang-bian-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="2.Linux命令（文档编辑）">
                        
                        <span class="card-title">2.Linux命令（文档编辑）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Linux命令（文档编辑）1.col​        col命令用于过滤控制字符。
在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符”&gt;”和”&gt;&gt;”，把说明文件的内容输出成纯文本文件时，控制字符会</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-08-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux笔记/" class="post-category" target="_blank">
                                    Linux笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux命令/" target="_blank">
                        <span class="chip bg-color">Linux命令</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/08/17/linux/ming-ling/7.linux-ming-ling-xi-tong-guan-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="7.Linux命令（系统管理）">
                        
                        <span class="card-title">7.Linux命令（系统管理）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Linux命令（系统管理）1.adduser​        adduser命令用于新增使用者帐号或更新预设的使用者资料。
adduser与useradd指令为同一指令（经由符号连结的符号链接）。
使用权限：系统管理员。
adduser是增</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-08-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux笔记/" class="post-category" target="_blank">
                                    Linux笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux命令/" target="_blank">
                        <span class="chip bg-color">Linux命令</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2019 yoyo. All Rights Reserved.

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">221k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/LHL001/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:koper007@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2025685938" class="tooltipped" data-tooltip="QQ联系我: 2025685938" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2019, 06, 24, 00, 00, 00); //北京时间2019-06-24 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已安全运行  " + diffYears + " 年 " +  diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>